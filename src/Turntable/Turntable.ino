/*
 The idea to create a own inexpensive hard and software for a turntable was generated by this post from Frank:
   https://www.stummiforum.de/viewtopic.php?t=140471&start=401&sd=a

 He uses the 3D printed turntabele from
   https://www.thingiverse.com/thing:1837520
31083 30916 167

 Revision History:
 ~~~~~~~~~~~~~~~~~
 13.12.20:  - Setting zero position if more than one turn is detected in both directions
            - Fast move to contact point with poti
 15.12.20:  - Current for stepper (28BYJ-48) incremented 0.17V = 300mA to prevent
              loosing steps (Old: 0.14V = 200mA)
 21.12.20:  - Actual Current settings 0.24V (Changed back to 0.14 later because the stepper gets to hot)
 26.12.20:  - Reading the actual port from the step position if moved by poti
            - Using a quadratic function to define the speed for a finer positioning
            - Reading the Port_Pos[] directly from the EEPROM to save RAM
            - Use FastPin instead of digitalWrite function to save memory and speed op the program
 27.12.20:  - Added the rotation switch menu
 28.12.20:  - Saving the position to the EEPROM to avoid callibration at startup
            - Port numbers shown to the user start with 1 and not with 0
            - Corrected Get_Next_Port_from_Actual_Position() to be able to use negativ Port_Pos[] entries
            - Detect if the poti is not 0 at the beginning
 29.12.20:  - Added the polarisation relais function
 02.01.21:  - Support for the u8x8 display mode which saves 10% Flash and doesn't need RAM for the display buffer
            - Option to use a second lagrer font for the numbers
 03.01.21:  - Reset uses the Jump 0 command because the watchdog reset doesn't work when an old bootloader is used
            - Polarisation relais could be configured individuel for each port
 05.01.21:  - Added several functions to controll the turntable with DCC
            - Prevent overwriting the EEPROM by the NmraDcc library
            - Support for 0.96" OLED display with 128x64 pixel
            - Pin which indicates that the turntable is moving to conect a S88 modul.
 07.01.21:  - Added the ability to change the rotation / port number direction of the turntable "TURNTABLE_DIRECTION"
            - Port number could be selected in the "Save position" menu only once at the beginning to
              prevent wrong sequences. Call "Reset all" to change the sequence.
            - Moved the poti to A7 because A0 could also be used as output. This could be changed with:
                #define POTI_PIN A0
            - Moved the rotation switch button to A6. This could be changed with:
                #define ENCODER_SW_PIN 9
              to the old pin number in the config file
            - Light which flashes while the turntable moves
            - Added the "avdweb_AnalogReadFast.h library to read speed up the analog reading
            - Diagnose display to check the analog values
            - Activating a sound modul if the turntable starts/stops moving
            - Additional DCC functions for Sound and Light
 08.01.21:  - Last menu position is stored. By default the "Reverse" line is activated
              => A double click could be used to reverse the turntable.
              This is also useful to save the port positions...
            - Stopping fast if the poti is turned to 0. Prior the time depends on the last speed.
            - Added MOVING_FLASH_INVERS
            - Filling also the port positions of the oposite direction with standard values when the first
              port in oposite direction is defined
 09.01.21:  - Storing Act_Port to the EEPROM
            - New handling of the reverse command. The start port is stored to Rev_Port to be able to
              rotate back again. The display shoa the reverse port in a second line.
            - Soved problem with Port < 24 at two positions
              - caused the wrong turn direction at Port 0 when tuned the rotation key back to 24
              - storing the Act_Port in Reverse_TurnTable
            - Checked with the maximal PORT_CNT of 80.
            - Corrected Get_Next_Port_from_Actual_Position(). Problem if one port is left, the other right of 0
            - Zero position is always set in positive direction
              Could be disabled with #define ALWAYS_SET_ZERO_IN_POS_DIR  0
              Prior it was only set after one turn.
            - Reversing the turntable if the same port command is received twice.
              Could be disabeld with #define REVERSE_IF_SAME_PORT_IS_RECEIVED 0
              If it's disabled the sound is not played.
 10.01.21:  - Storing the reverse positions to the EEPROM to be able to adjust them individually
            - Replaced the "Move_to_Port_or_Pos()" Function by two separate functions:
              "Move_to_Port()" and "Move_to_StepPos()" because the old function used the value of the parameter
              to detect if it was ment as Port or StepPos (Abs(x) < 2*PORT_CNT). This was fine for manual
              tests, but can't be used in an automatic mode where a StepPos could also be < PORT_CNT.
 11.01.21:  - Disabled the flickering of the display if USE_u8x8 is used
            - New menu option "Move manual"
            - Improved the decoding of the rotation switch
            - Corrected playing sound at the beginning of the movement
 12.01.21:  - Using the serial port to play the sounds
              - Number of sounds could be lager. At the moment 8 files could be used with DCC
              - Is connected to the serial port => No other pin needed
              - Debug outputs must use 9600 Baud ;-( but debuging is still possible in paralel
              - DCC Functions added to change the volume
            - Don't reverse per DCC while moving
 17.01.21:  => Send to Han
            - Moving to contact before moving to a port. This caused a lot of changes.
            - Delayed start moving if DELAY_TURN_START_SOUND is given
 23.01.21:  - Added Menu Sound


                         +-----+
            +------------| USB |------------+                     If the TMC2100 stepper driver is used the enable pin is not needed
            |            +-----+            |                     For the A4988 a pullUp resistor is usefull to disable the power while programming
     (CAN)  | [ ]D13/SCK        MISO/D12[ ] |        (CAN)
            | [ ]3.3V           MOSI/D11[ ]~|        (CAN)
            | [ ]V.ref     ___    SS/D10[ ]~|-Light
   (Sound1)-| [ ]A0       / N \       D9[ ]~|-------------,
Poarisation-| [ ]A1      /  A  \      D8[ ] |---------,   |
   S88 Turn-| [ ]A2      \  N  /      D7[ ] |---------|---|------------------* /   Zero switch
 Turn Flash-| [ ]A3       \_0_/       D6[ ]~|---------|---|---!Enab A         /    Could also be
 OLED   SDA-| [ ]A4/SDA               D5[ ]~|---------|---|---Dir   49      _|_    a hall switch (Ex: TLE4905L)
 Disp   SCL-| [ ]A5/SCL               D4[ ] |-(SX/CAN)|   '---Step  88           _______
  ,-Buttons-| [ ]A6              INT1/D3[ ]~|---------|---,                 +5V-|8     2|----[1K]----
  |    Poti-| [ ]A7              INT0/D2[ ] |---------|---|---------------------|6 Opto |            DCC
  *-[10k]---| [ ]5V                  GND[ ] |         |   | 100nF            ,--|5     3|----|>|-----
  |         | [ ]RST                 RST[ ] |         *---|--||--|          _|_ |_______|
  |         | [ ]GND   5V MOSI GND   RX1[ ] |         |   | 100nF                 6N137
  |      .  | [ ]Vin   [ ] [ ] [ ]   TX1[ ] |-Sound   | _ *--||--|
  |         |          [ ] [ ] [ ]          |         |_|_|
  |         |          MISO SCK RST         |        |B C A|  Rotary switch
  |         | NANO-V3                       |        |  *  |  Reichelt: STEC11B13  (Ali: https://de.aliexpress.com/item/32462116984.html)
  |         +-------------------------------+        |_____|  (C = GND)                  Allready has a 10K pull up
  |                                                    | |
  '----------------------------------------------------' |
       If the Buttons line is used in addition          _|_
       to read in other buttons the PullUp in the
       rotation switch has to be removed


 ToDo:
 ~~~~~
 - Geschwindigkeiten und andere Parameter wie ANALOG_SPEED_DIVISOR, FAST_MOVE_MANUAL_STEP,
   SLOW_MOVE_MANUAL_STEP, ... sollen automatisch angepasst werden.
   Sie sollen sich an MOVE_SPEED1 orientieren und evtl. an der Anzahl der Schritte.
 - Sound Menu ersetzen durch einen Befehl "Sound On/Off" im Hauptmenu
 - Nach dem Recal per Menu soll er wieder zu letzten Position fahren
 - Die "Only this" Abfrage soll nicht kommen wenn noch nichts definiert ist
 - Möglichkeit zur festen Definition der StepsOneTurn
 - Wenn der Sound Aktiviert ist dann soll der Stepper verzögert starten
   Ich habe das mal auch die schnelle per Delay eingabaut. Das ist aber noch nicht gut weil
   dann der Drehschalter nicht mehr eingelesen wird
 - Der zweite Sound soll vor dem Ende gestartet werden können da es eine gewisse Zeit dauert
   bis das Sound Modul reagiert
 - Die Sound Nummer welche dem Start und Ende Ereignis zugeordenet wird habe ich parametrierbar bemacht
   Das ist aber noch nich logisch => Namen ändern Mode?, ...
 - Das Recalibrate dreht keine Runde mehr ;-(
   => Wird nur gemacht wenn das EEPROM Gelöscht wurde
 - Thermisches Modell für Spielzeug Stepper?
 - Hysterese Berücksichtigen!
 -  Pins D1-D13 als define anlegen
 - Untersuchen wie sich der Stepper verhält wenn der Strom neu eingeschaltet wird
   - Vermutlich ist das nicht immer wegen der Reibung vorhersagbar.
 - Nach dem "Recalibrate" sollte er wieder zur letzen Position fahren oder?
 - Beim ersten Start automatisch den Nullpunkt abgleichen
 - Bei einem Stepper ohne (nennenswertes) Getriebe muss der Micro Stepps Offset gespeichert
   werden und beim Einschalten der Versorgungsspannung wieder restauriert werden.
 - 0 Punkt des Potis automatisch kalibrieren
 - Selextrix
 - CAN
 - Lost Stepps Test welcher die Scheibe mehrfach schnell in die eine Richtung beschleunigt
   und dann langsam wieder zurück dreht. Am Ende wird der 0-Punkt geprüft
 - Segment Drehscheibe
 - Serielle Schnittstelle deaktivierbar machen zum Speicher sparen
 - Warum ist die Messung der StepsOneTurn so ungenau? 940.87 mm - 942.73 mm
   => Beim großen Stepper stimmt ist es ganz genau 3200
 - Ausgabe in verschiedenen Sprachen


 Vielleicht Später:
 ~~~~~~~~~~~~~~~~~~
 - 4 Tasten per DCC mit denen die Scheibe fein positioniert werden kann
 - Tasten für + und -. Diese können evtl. Analog eingelesen werden
 - Der Drehschalter funktioniert nicht immer so richtig. Hardware Problem?
   => Mal mit einem optischen Schalter testen
 - Ungültige Einträge im Port_Pos[] erkennen und korrigieren
   - Die Positionen müssen aufsteigend sein
   - nicht größer als ee.StepsOneTurn sein
   - >= 0
 - Möglichkeit zum sperren bestimmter Ports
 - Analog Wert per Interrupt lesen (z.B. mit "AnalogScanner")
   => Braucht viel Speicher FLASH: 664    RAM: 115
 - Float Umwandling mit "dtostrf()"
     https://www.nongnu.org/avr-libc/user-manual/group__avr__stdlib.html#g6c140bdd3b9bd740a1490137317caa44
 - Menu (In verschiedenen Sprachen):

 Verworfen:
 ~~~~~~~~~~
 - Menu Timeout => Nein, Das ist ein Feature mit dem man die DCC commandos abschalten kann
 - Im Display anzeigen wenn HasContact(2) ist
 - Was ist, wenn man die Nummerierung aller Punkte ändern will
   Wenn also die aktuelle Position stark von der gespeicherten Position abweicht
   Dann sollten alle Punkte neu gesetzt werden wie wenn das EEPROM Neu ist
   => Dazu muss man im Menü "Reset all" aufrufen
 - Das Poti kann dazu benutzt werden bestimmte Aktionen auszulösen
   - StepsOneTurn neu einlesen beim Start  => Geht auch per Menu
   - Keine initialisierung der Positionen  => Wozu?
 - Wenn man 3 mal nacheinander den gleichen Port korrigiert hat, dann kann man den Nullpunkt neu einlesen
   => Manuell per Menu machen
 - StepsOneTurn lernen wenn die Zero Position erkannt wird => Sollte sich eignetlich nicht verändern
 - CheckAndSetZero() auf Interrupts umbauen
   => Hat nichts gebracht ;-(
   Evtl. Nötig wenn zu viele DCC Signale kommen
 - Serielle Befehle
   - Port Position speichern Ohne +/- => Nein, nicht nötig
 - Manchmal bewegt er sich nicht gleich per Poti => Nicht mehr aufgefallen (28.12.20)

 Notizen:
 ~~~~~~~~
 - Wenn der Stepper heiß ist, dann kann schmilzt das 3D gedruckte Zahnradund er rutscht mechanisch durch ;-(
 - Maximal benötigter PORT_CNT 48 (7.5° Teilung) => 384 Byte EEPROM bei zwei Werten pro Port
   - EEPROM Größe Nano 1024
   => Das passt
   Frank Bahnpark: 6° => 60 Positionen => 480 Byte
 - Achtung: Die Silent2100 Stepper Platine hat das Poti an der anderen Seite. Darauf muss man beim tausch
   gegen den A4988 achten sonst brennt der Arduino und die Stepper Platine dürch ;-(
   => Schutzwiderstände einbauen
 - Der "große" Stepper braucht einen deutlich größeren Strom sonst ruckt er start
   (Dann scheinen die mikro steps nicht so richtig zu gehen)

 Tests:
 ~~~~~~
 - Was passiert wenn ee.Steps_Has_Contact = 0?
   => Kein Problem    07.01.21:

 Stepper Treiber Platinen
 ~~~~~~~~~~~~~~~~~~~~~~~~
 Es gibt verschiedene Stepper Platinen:
 - A4988    1/16
 - DRV8825  1/32  (15 Stück Bestellt 04.12.20)
   - Der 5V pin kann auch als Fault Ausgang belegt sein trotzdem wird hier 5V angeschlossen:
     https://de.aliexpress.com/item/32963690420.html?spm=a2g0s.9042311.0.0.1ec54c4dF89RwO
   - Reset und Sleep Pin nicht immer vorhanden
 - TMC2100  Viel leiser (Doppelt so teuer)  https://wiki.fysetc.com/TMC2100/  (04.12.20:  5 Stück bestellt)
   Ander Mode Funktionen: https://reprap.org/wiki/TMC2100/de
   - Irgend wie funktioniert bei meiner Platine die Mode Umschaltung nicht so wie das beschrieben ist.
     - Lötjumper auf der Unterseite (Standardmäßig alle offen)
       Die Lötjumper CFG1 & CGF2 haben keine Verbindung zu den Pins am Stecker
       Man kann den Mode nur über die Lötjumper ändern. Per Default steht er auf 1/16
       Beim A4988 müssen dafür alle MCfg Pins auf 5V gelegt werden
       - Laut Beschreibung werden die CF1 und CF2 benutzt wenn CF3 offen ist.
         Das scheint nicht zu stimmen
         Evtl. Bedeutet das "Int" in der Beschreibung Interpolation
         Wenn CGF3 Offen ist, dann brummt er
       - Wenn man den Lötjumper CFG2 mit Masse verbindet, dann arbeitet der Stepper im 1/2 Stepp Modus.
         Das stimmt mit der Beschreibung überein.
         Über CFG3 (Lötjumper verbinden) kann man die Betriebsart irgend wie verändern?
         Am besten läuft er wenn CFG3 auf 5V liegt
   - Enable und nicht wie beim A4988 ein NOT Enable Pin
   - Cfg1 & 2 Pins haben 3 mögliche Positionen 0/open/5V
   - Drehrichtung invers wie A4988
 - TMC2130 hat SPI und Step/Dir Interface
   Library:
    - https://github.com/teemuatlut/TMCStepper
    - https://github.com/janelia-arduino/TMC2130

 - TMC2208 RS232 Programmierbar
 - TMC2209 wie TMC2208 aber höherer Strom



 Features von DSD2010
 ~~~~~~~~~~~~~~~~~~~~
   https://www.digital-bahn.de/bau_ds2010/dsd2010_konzept.htm
   https://digital-bahn.de/shopping/mediafiles/pdf/dsd2010_anleitung_1v7.pdf
   https://stummiforum.de/viewtopic.php?t=163337
   - Eigenes Bühnen Modul:
     - Automatisch Ansteuerung von Signalen auf der Bühne                          Könnte über WS281x gemacht werden
     - Ansteuerung des Lichts im Haus auf der Bühne
     - Ansteuerung eines Blinklichtes, welches während der Drehung aktiv ist.
     - Sound                                                                       Unter der Bühne Montieren
   - Rückmeldung an Zentrale "Bühne dreht" oder Ist-Position über S88
   - Gleis Belegt Melder auf Bühne
   - Kehrschleifenmodul (Wird abhängig von der Stellung der Bühne gemacht)         O.k.

 Gedanken zum Umbau einer Märklin/Trix Scheibe
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 - Man bräuchte einen Stepper mit den Abmessungen des normalen Motors
 - Ein Modul auf die Scheibe mit A4988, Steuerung der LEDs, GBM, ...
   Die Platine muss ziemlich klein werden
 - Ein zweites Modul unten, Display, DrehDrück, Poti, ...
 - Kommunikation zwischen den Modulen I2C (Mit CRC)
 - Die Scheibe hat 5 Schleifkontakte
   - 2 x Gleisspannung
   - 3 x I2C + GND
   Evtl. könnte man eine Leitung der Gleisspannung als GND verwenden
 - Alternativ könnte man aber auch die gesammte Elektronik in die Grube packen
   Dazu müsste die Spannung für die Platinen unabpängig von Gleis sein. Dann könnte
   man eine Gleisspannung über ein Stepper Kabel Schicken
   5 Kabel: 4*Stepper Kabel + 1 Gleis
   - Beleuchtung auf der Bühne müste dann ganz über DCC laufen
   - Man könnte die Stepper Leitungen wenn dieser steht und Stromlos ist auch
     zu Kommunikation benutzen. So könnte man den Gleis Belegt status übertragen indem
     man eine Stepper Leitung hochohmig gegen masse zieht.
 => Vielleicht irgend wann einmal...

 Links:
 ~~~~~~
 - Ähnliche Projekte:
     Von 2017:     https://mrrwa.org/2017/12/23/dcc-controlled-turntable-stepper-motor-driver/
     Nicht fertig: https://www.stummiforum.de/viewtopic.php?f=21&t=182402&sid=d002ca107d56baf727135ff4e7863b70
     Holz Scheibe: https://www.stummiforum.de/viewtopic.php?f=27&t=168699&p=2144419#p2144237

 - Drehscheibe von Sven Brandt:
     https://www.digital-bahn.de/bau_ds2010/dsd2010.htm
 - FastLED:
     http://fastled.io/docs/3.1/index.html
 - JQ6500:
    https://github.com/sleemanj/JQ6500_Serial
*/

#define VerStr "V0.6"

// Helper macros for DCC adresses
#define DCC_CHKADDR(Addr, Dir)              (Addr*2 + Dir)
#define CHECK_ADDR(AddDir)                  (AddDir < 0 || (AddDir >= FIRST_USED_DCC_ADDR && AddDir <= LAST_USED_DCC_ADDR))
#define DCC_ADD_DIR(Addr, Dir)              (Addr*2 + Dir) / CHECK_ADDR((Addr*2 + Dir))  // Generates "warning: division by zero" if FIRST_USED_DCC_ADDR or LAST_USED_DCC_ADDR are wrong
#define DCC_PORT_ADDR(Nr, Addr, Dir)        DCC_ADD_DIR(Addr, Dir)
#define RED                                 0
#define GRN                                 1


#include "Turntable_Config.h"       // Local configuration file. The file could be empty. In this case the default values are used (See below).

//************************************************************************************************************
//
// The following lines could be used in the "Turntable_Config.h". The default values are used if the
// corrosponding line is missing in the file.
//
#ifndef ALLWAYS_CHECK_STEPS_ONE_TURN
#define ALLWAYS_CHECK_STEPS_ONE_TURN        0           // Always check the steps for one turn at power on
#endif
#ifndef PORT_CNT
#define PORT_CNT                            24          // Number of ports (Maximal 80)
#endif                                                  // Attention: The DCC_PORT_ADDR() list and POLARISATION_RELAIS_LIST has to be adapted also !!
#ifndef CIRCUMFERENCE
#define CIRCUMFERENCE                       942.5       // 300 mm * Pi circumference of the turntable [mm] (Used for tests displays only)
#endif
#ifndef ROTATIONSWITCH_DIRECTION
#define ROTATIONSWITCH_DIRECTION            1           // Set to -1 to change the direction of the rotation switch (Also used for the menu)
#endif
#ifndef ROTATIONSWITCH_MENU_DIR
#define ROTATIONSWITCH_MENU_DIR             1           // Set to -1 to change the direction of the rotation switch in the menu
#endif
#ifndef ALWAYS_CALIBRATE_AT_START
#define ALWAYS_CALIBRATE_AT_START           0           // // Set to 1 to calibrate the position every time when the program is started
#endif                                                  // If it's set to 0 the calibration is only called if necessary
#ifndef ALWAYS_SET_ZERO_IN_POS_DIR
#define ALWAYS_SET_ZERO_IN_POS_DIR          1
#endif

#ifndef TURNBACK_SPEED
#define TURNBACK_SPEED                      15000       // Speed used for TurnBackAndSetZero
#endif

#ifndef SPEED_POTI_DIRECTION
#define SPEED_POTI_DIRECTION                1           // Set to -1 to change the direction of the speed poti
#endif

// *** Pins ***
#ifndef POTI_PIN
#define POTI_PIN                            A7          // Pin used for the speed potentiometer
#endif
#ifndef ENCODER_A_PIN
#define ENCODER_A_PIN                       3           // Best Performance: both pins have interrupt capability
#endif
#ifndef ENCODER_B_PIN
#define ENCODER_B_PIN                       8           // Good Performance: only the first pin has interrupt capability
#endif
#ifndef ENCODER_SW_PIN
#define ENCODER_SW_PIN                      A6          // Encoder switch pin (Other side connected to GND)
#endif
#ifndef STEP_PIN
#define STEP_PIN                            9          // Old: D4
#endif
#ifndef DIR_PIN
#define DIR_PIN                             5
#endif
#ifndef NOT_ENABLE_PIN
#define NOT_ENABLE_PIN                      6           // Set to -1 if the stepper driver has an automatic power mode like the TMC2100
#endif                                                  // The pin of the module must be left open
#ifndef ZERO_SW_PIN
#define ZERO_SW_PIN                         7           // Switch connected to GND or low active reflex coupler
#endif
#ifndef STATUS_LED_PIN
#define STATUS_LED_PIN                      LED_BUILTIN
#endif

// *** Polarization relays ***
#ifndef POLARISATION_RELAIS_PIN
#define POLARISATION_RELAIS_PIN             A1          // Polarization relays for dual rail system (Set to -1 if not used)
#endif
#ifndef POLARISATION_RELAIS_INVERS                      // 0: Pin is set to high POLARISATION_RELAIS_LIST[Port] = 1
#define POLARISATION_RELAIS_INVERS          0           // 1: Pin is set to low
#endif
#ifndef POLARISATION_RELAIS_LIST   // Port: 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
#define POLARISATION_RELAIS_LIST            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
#endif

#ifndef MOVE_STATUS_PIN                                 // This pin is active (5V) if the turntable is moving
#define MOVE_STATUS_PIN                     A2          // It could be inverted with MOVE_STATUS_INVERS
#endif                                                  // If the pin is set to -1 it's disabled
                                                        // Attention: The moving state is not changed if the menu is opened
                                                        // to prevent that the master control program sends new commands.
#ifndef MOVE_STATUS_INVERS
#define MOVE_STATUS_INVERS                  0           // Invert the level of the MOVE_STATUS_PIN. 1 => moving = 0V
#endif                                                  // The !Enable pin to the A4988 could be used instead

#ifndef MOVING_FLASH_PIN                                // Flashing while the turntable is moving
#define MOVING_FLASH_PIN                    A3          // The LED is connected to GND
#endif
#ifndef MOVING_FLASH_MODE
#define MOVING_FLASH_MODE                   1           // 1 = Blink, 2 double flash
#endif
#ifndef MOVING_FLASH_TIME1
#define MOVING_FLASH_TIME1                  250         // Time used to change the flashlight in mode 1
#endif
#ifndef MOVING_FLASH_TIME2_1
#define MOVING_FLASH_TIME2_1                48          // Flash times in mode 2
#endif
#ifndef MOVING_FLASH_TIME2_2                            // ,-,   ,-,
#define MOVING_FLASH_TIME2_2                74          // | |   | |
#endif                                                  // ' '---' '---------
#ifndef MOVING_FLASH_TIME2_3                            // T1 T2    T3
#define MOVING_FLASH_TIME2_3                494
#endif
#ifndef MOVING_FLASH_INVERS                             // Invert the level of the LED.
#define MOVING_FLASH_INVERS                 0           // Normal: 0 = LED connected to GND
#endif                                                  //         1 = LED connected to +5V

#ifndef SOUND_PIN1                                      // Trigger an external sound module when the turntable
#define SOUND_PIN1                          -1          // starts or stops moving (See SOUND_MODE)
#endif
#ifndef SOUND_PIN2                                      // Trigger an external sound module when the turntable
#define SOUND_PIN2                          -1          // starts or stops moving (See SOUND_MODE)
#endif                                                  // or per DCC
#ifndef SOUND_PIN3
#define SOUND_PIN3                          -1          // Trigger an external sound module per DCC
#endif
#ifndef SOUND_PIN4
#define SOUND_PIN4                          -1          // Trigger an external sound module per DCC
#endif
#ifndef SOUND_MODE1                                     // Mode 1 = Trigger a sound when the turntable starts
#define SOUND_MODE1                         1           // Mode 2 = .. when stops (1+2=start and stop)
#endif                                                  // or per DCC
#ifndef SOUND_MODE2                                     // Mode 1 = Trigger a sound when the turntable starts
#define SOUND_MODE2                         2           // Mode 2 = .. when stops (1+2=start and stop)
#endif                                                  // or per DCC
#ifndef SOUND_ACT_DURATION
#define SOUND_ACT_DURATION                  100         // Time how long the sound pin is activated [ms]
#endif
#ifndef DELAY_TURN_START_SOUND
#define DELAY_TURN_START_SOUND              1500        // Delay before start moving if sound is played
#endif
#ifndef SOND1_FILENR
#define SOND1_FILENR                        1
#endif
#ifndef SOND2_FILENR
#define SOND2_FILENR                        2
#endif


#ifndef SOUND_POTI_MOVE                                 // Play the sounds also when moving with the poti
#define SOUND_POTI_MOVE                     0           // and when the DCC_ROTATE_xxx_DIR_ADDR is used
#endif                                                  // If the switch is set to 0 the sounds are only
                                                        // played in the automatic modes

#ifndef USE_JQ6500_SERIAL                               // Use a JQ6500 sound module which is connected via the serial pins
#define USE_JQ6500_SERIAL                   1           // SMART_JQ6500_SERIAL_PIN --[1K]-- TX
#endif                                                  // If SOUND_PIN1 = -1 the hardware serial pin is used

#ifndef SMART_JQ6500_SERIAL_PIN                         // Define the pin number used for the sound modul
#define SMART_JQ6500_SERIAL_PIN            -1          // -1 = hardware serial. This is the fastest method
#endif                                                  // to activate a sound (42us). 6.4ms are needed with
                                                        // another pin ;-(

#ifndef JQ6500_VOLUME                                   // Set the volume of the JQ6500 sound module at power on
#define JQ6500_VOLUME                       -1          // Range: 0..30   (-1 = Don't change the volume)
#endif
#ifndef SOUND_VOLUME1
#define SOUND_VOLUME1                       10          // Set the volume by the DCC addr DCC_VOLUME_1_ADDR
#endif
#ifndef SOUND_VOLUME2
#define SOUND_VOLUME2                       20          // Set the volume by the DCC addr DCC_VOLUME_2_ADDR
#endif

#ifndef LIGHT_PIN
#define LIGHT_PIN                           10          // Light in the machine house on the turntable
#endif


// *** OLED ***
#ifndef USE_OLED
#define USE_OLED                            1           // Use an OLED Display (Could be disabled to save memory for tests. The outputs are send to RS232
#endif
#ifndef OLED_TYP                                        // 0.87", 0.91" or 0.96" display (87/91/96)
#define OLED_TYP                            91          // Tested with the following displays
#endif                                                  // 0,87" I2C 128x32 OLED  SSD1316  (https://de.aliexpress.com/item/4000182887362.html)
                                                        // 0.91" I2C 128x32 OLED  SSD1306  (https://de.aliexpress.com/item/4001028654247.html)
                                                        // 0,96" I2C 128X64 OLED  SSD1306  (https://de.aliexpress.com/item/32643950109.html)
                                                        // The 0.96" Display uses 2% less memory because there only one font is used
                                                        // But it's only available if USE_u8x8 is active


#ifndef ROTATE_DISPLAY_180_DEG
#define ROTATE_DISPLAY_180_DEG              0           // Rotate the display by 180° => Pins are at the right side
#endif
#ifndef USE_u8x8                                        // Saves 10% FLASH, but only supports text output at pixel pos x * 8
#define USE_u8x8                            1           // But the text is redrawn if it's changed.
#endif
#ifndef NO_FLICKER_u8x8
#define NO_FLICKER_u8x8                     1           // Disable the flickering if USE_u8x8 is active (Uses 74 bytes FLASH)
#endif
#ifndef USE_LARGE_FONT_FOR_NUMBERS
#define USE_LARGE_FONT_FOR_NUMBERS          1           // Use a large font for numbers. The font is defined with LARGE_FONT_FOR_NUMBERS
#endif
#ifndef OLED_CONTRAST                                   // Set the contrast or brightness for the display (if supported).
#define OLED_CONTRAST                       -1         // Range: 0 (no contrast) to 255 (maximum contrast or brightness)
#endif                                                  // -1 = Use standard (and save 22 bytes FLASH)

#ifndef USE_DIAGNOSE_DISP                               // Enable a diagnose display in the menu to check the poti and the rotation key
#define USE_DIAGNOSE_DISP                   1           // Uses 162 Bytes FLASH
#endif

// *** Fonts ***
// https://github.com/olikraus/u8g2/wiki
//
// U8g2 Font names
// <prefix> '_' <name> '_' <purpose> <char set>
// <purpose> Description
// t Transparent font, Do not use a background color.
// h All glyphs have common height.
// m All glyphs have common height and width (monospace).
// 8 All glyphs ?t into a 8x8 pixel box.
// <char set> Description
// f The font includes up to 256 glyphs.
// r Only glyphs on the range of the ASCII codes 32 to 127 are included in the font.
// u Only glyphs on the range of the ASCII codes 32 to 95 (uppercase chars) are included in the font.
// n Only numbers and extra glyphs for writing date and time strings are included in the font.
// ... Other custom character list.

#if USE_u8x8 == 1
   // Fonts for USE_u8x8:
   //   https://github.com/olikraus/u8g2/wiki/fntlist8x8
   #if OLED_TYP == 96
     #ifndef NORMAL_FONT
     #define NORMAL_FONT            u8x8_font_8x13B_1x2_r
     #endif
     #ifndef U8G_FONT_HEIGHT
     #define U8G_FONT_HEIGHT 2
     #endif
     #undef USE_LARGE_FONT_FOR_NUMBERS
     #define USE_LARGE_FONT_FOR_NUMBERS 0
   #else
     #ifndef NORMAL_FONT
     #define NORMAL_FONT            u8x8_font_amstrad_cpc_extended_r
     #endif
     #ifndef LARGE_FONT_FOR_NUMBERS
     #define LARGE_FONT_FOR_NUMBERS u8x8_font_8x13B_1x2_r
     #endif
   #endif
#else
   // Fonts if USE_u8x8 = 0
   //   https://github.com/olikraus/u8g2/wiki/fntlistall#14-pixel-height
   #ifndef NORMAL_FONT
   #define NORMAL_FONT            u8g2_font_pxplustandynewtv_8r // 8x8 only 32-127  872 Bytes   (See: u8g2fntlistall.pdf)
   #endif
   #ifndef LARGE_FONT_FOR_NUMBERS
   #define LARGE_FONT_FOR_NUMBERS u8g2_font_9x18B_mn
   #endif
#endif


#ifndef USE_JMP0_RESET
#define USE_JMP0_RESET                      1           // Activate if a (very) old bootloader is used. In this case the watchdog reset doesn't work
#endif

// *** Stepper ***
#ifndef STEPPER_RAMP_LENGTH
#define STEPPER_RAMP_LENGTH                 100
#endif

#ifndef MOVE_SPEED1
#define MOVE_SPEED1                         25000       // Default speed and activated when DCC_SET_SPEED1_ADDR is received
#endif
#ifndef MOVE_SPEED2
#define MOVE_SPEED2                         15000       // Speed activated when DCC_SET_SPEED2_ADDR is received
#endif
#ifndef MOVE_SPEED3
#define MOVE_SPEED3                         10000       // Speed activated when DCC_SET_SPEED3_ADDR is received
#endif
#ifndef MOVE_SPEED4
#define MOVE_SPEED4                         5000        // Speed activated when DCC_SET_SPEED4_ADDR is received
#endif

#ifndef CLEARENCE_TEST_SPEED
#define CLEARENCE_TEST_SPEED                25000       // Speed used in the clearance test
#endif
#ifndef CALIBRATE_SPEED
#define CALIBRATE_SPEED                     25000       // Speed used for the zero point and total number of stepps detection
#endif

#ifndef ANALOG_SPEED_DIVISOR
#define ANALOG_SPEED_DIVISOR                8           // Divisor used to calculate the analog speed with the poti
#endif
#ifndef MIN_ANALOG_SPEED                                // Speed in steps/10sec. If the minimal speed is to small the repons time is to high
#define MIN_ANALOG_SPEED                    20          // 1 => 10 sec reaction time ;-(   Reaction time = 10 sec / MIN_ANALOG_SPEED
#endif
#ifndef MIN_STEPS_HAS_CONTACT                           // Don't move fast to the contact point in the "Poti" mode if Steps_Has_Contact
#define MIN_STEPS_HAS_CONTACT               30          // Is below the given value. Set to -1 to disable the check (Always move fast to the contact point)
#endif                                                  // Problem: The Steps_Has_Contact detection may be not accurate because of sensor errors

#ifndef FAST_MOVE_MANUAL_STEP
#define FAST_MOVE_MANUAL_STEP               32          // Step size in "Move manual" mode if the rotation switch is turned fast
#endif
#ifndef SLOW_MOVE_MANUAL_STEP
#define SLOW_MOVE_MANUAL_STEP               1           // Step size in "Move manual" mode if the rotation switch is turned slow
#endif

#ifndef TURNTABLE_DIRECTION
#define TURNTABLE_DIRECTION                 1           // Set to -1 to change the rotation / port number direction
#endif

#ifndef REVERSE_IF_SAME_PORT_IS_RECEIVED
#define REVERSE_IF_SAME_PORT_IS_RECEIVED    1           // Reverse by 180° if the same port command is received twice
#endif

#ifndef USE_3_PORT_POS
#define USE_3_PORT_POS                      1           // Store a third port position for the reversed port (496 Byte FLASH)
#endif

#ifndef ASK_TO_UPDATE_ALL
#define ASK_TO_UPDATE_ALL                   1           // 1:  Ask to update all ports when Port 1 is redefined
                                                        // >1: Ask to update all ports for every port
#endif

// *** DCC ***
#ifndef USE_DCC
#define USE_DCC                             1           // Use a DCC interface
#endif

// DCC Commands are ignored while the menu is active and during calibration. => Activate the menu to disable DCC

#ifndef FIRST_USED_DCC_ADDR
#define FIRST_USED_DCC_ADDR                 DCC_CHKADDR(214, RED)       // Used to speed up the program. Must be set to the first used address
#endif

// Use negativ addresses to disable the corrosponding command
#ifndef DCC_DISABLE_SOUND_ADDR
#define DCC_DISABLE_SOUND_ADDR              DCC_ADD_DIR(214, RED)       // Disable the automatic generated sound if the turntable starts/stops moving
#endif
#ifndef DCC_ENABLE_SOUND_ADDR
#define DCC_ENABLE_SOUND_ADDR               DCC_ADD_DIR(214, GRN)       // Enable the automatic generated sound if the turntable starts/stops moving
#endif
#ifndef DCC_VOLUME_DN_ADDR
#define DCC_VOLUME_DN_ADDR                  DCC_ADD_DIR(215, RED)       // decrease the volume
#endif
#ifndef DCC_VOLUME_UP_ADDR
#define DCC_VOLUME_UP_ADDR                  DCC_ADD_DIR(215, GRN)       // increase the volume
#endif
#ifndef DCC_VOLUME_1_ADDR
#define DCC_VOLUME_1_ADDR                   DCC_ADD_DIR(216, RED)       // Set the sound volume to SOUND_VOLUME1 (10 by default)
#endif
#ifndef DCC_VOLUME_2_ADDR
#define DCC_VOLUME_2_ADDR                   DCC_ADD_DIR(216, GRN)       // Set the sound volume to SOUND_VOLUME2 (20 by default)
#endif

#ifndef DCC_PLAY_SOUND1_ADDR
#define DCC_PLAY_SOUND1_ADDR                DCC_ADD_DIR(217, RED)       // Play sound 1
#endif
#ifndef DCC_PLAY_SOUND2_ADDR
#define DCC_PLAY_SOUND2_ADDR                DCC_ADD_DIR(217, GRN)       // Play sound 2
#endif
#ifndef DCC_PLAY_SOUND3_ADDR
#define DCC_PLAY_SOUND3_ADDR                DCC_ADD_DIR(218, RED)       // Play sound 3
#endif
#ifndef DCC_PLAY_SOUND4_ADDR
#define DCC_PLAY_SOUND4_ADDR                DCC_ADD_DIR(218, GRN)       // Play sound 4
#endif
#ifndef DCC_PLAY_SOUND5_ADDR
#define DCC_PLAY_SOUND5_ADDR                DCC_ADD_DIR(219, RED)       // Play sound 5
#endif
#ifndef DCC_PLAY_SOUND6_ADDR
#define DCC_PLAY_SOUND6_ADDR                DCC_ADD_DIR(219, GRN)       // Play sound 6
#endif
#ifndef DCC_PLAY_SOUND7_ADDR
#define DCC_PLAY_SOUND7_ADDR                DCC_ADD_DIR(220, RED)       // Play sound 7
#endif
#ifndef DCC_PLAY_SOUND8_ADDR
#define DCC_PLAY_SOUND8_ADDR                DCC_ADD_DIR(220, GRN)       // Play sound 8
#endif
#ifndef DCC_DISABLE_LIGHT_ADDR
#define DCC_DISABLE_LIGHT_ADDR              DCC_ADD_DIR(221, RED)       // Disable the light in the machine house on the turntable
#endif
#ifndef DCC_ENABLE_LIGHT_ADDR
#define DCC_ENABLE_LIGHT_ADDR               DCC_ADD_DIR(221, GRN)       // Enable the light
#endif
#ifndef DCC_SET_SPEED1_ADDR
#define DCC_SET_SPEED1_ADDR                 DCC_ADD_DIR(222, RED)       // Set the moving speed to MOVE_SPEED1
#endif
#ifndef DCC_SET_SPEED2_ADDR
#define DCC_SET_SPEED2_ADDR                 DCC_ADD_DIR(222, GRN)       // Set the moving speed to MOVE_SPEED2
#endif
#ifndef DCC_SET_SPEED3_ADDR
#define DCC_SET_SPEED3_ADDR                 DCC_ADD_DIR(223, RED)       // Set the moving speed to MOVE_SPEED3
#endif
#ifndef DCC_SET_SPEED4_ADDR
#define DCC_SET_SPEED4_ADDR                 DCC_ADD_DIR(223, GRN)       // Set the moving speed to MOVE_SPEED4
#endif
#ifndef DCC_STEP_POS_DIR_ADDR
#define DCC_STEP_POS_DIR_ADDR               DCC_ADD_DIR(224, RED)       // Turn to the next port in positive direction
#endif
#ifndef DCC_STEP_NEG_DIR_ADDR
#define DCC_STEP_NEG_DIR_ADDR               DCC_ADD_DIR(224, GRN)       // Turn to the next port in negative direction
#endif
#ifndef DCC_ROTATE_POS_DIR_ADDR
#define DCC_ROTATE_POS_DIR_ADDR             DCC_ADD_DIR(225, RED)       // Continiously rotate in the positive direction
#endif
#ifndef DCC_ROTATE_NEG_DIR_ADDR
#define DCC_ROTATE_NEG_DIR_ADDR             DCC_ADD_DIR(225, GRN)       // Continiously rotate in the negative direction
#endif
#ifndef DCC_STOPP_ADDR
#define DCC_STOPP_ADDR                      DCC_ADD_DIR(226, RED)       // Stop the turntable
#endif
#ifndef DCC_CALIBRATE_ADDR
#define DCC_CALIBRATE_ADDR                  DCC_ADD_DIR(226, GRN)       // Calibrate the zero position (During the calibration no other commands are accepted)
#endif
#ifndef DCC_SET_POL_REL0_ADDR
#define DCC_SET_POL_REL0_ADDR               DCC_ADD_DIR(227, RED)       // Set the polarisation to RED and disable the automatic
#endif
#ifndef DCC_SET_POL_REL1_ADDR
#define DCC_SET_POL_REL1_ADDR               DCC_ADD_DIR(227, GRN)       // Set the polarisation to GRN and disable the automatic
#endif
#ifndef DCC_AUTO_POL_REL_ADDR
#define DCC_AUTO_POL_REL_ADDR               DCC_ADD_DIR(228, RED)       // Enable the automatic polarisation mode. The releai wil be set after the next move
#endif
#ifndef DCC_REVERSE_TABLE_ADDR
#define DCC_REVERSE_TABLE_ADDR              DCC_ADD_DIR(228, GRN)       // Reverse the turntabel
#endif

// List of DCC adresses to move to the desired port. Must contain exact PORT_CNT entries. If not a compiler error is generated.
#ifndef DCC_PORT_ADDR_LIST
#define DCC_PORT_ADDR_LIST                  DCC_PORT_ADDR(1, 229, RED), \
                                            DCC_PORT_ADDR(2, 229, GRN), \
                                            DCC_PORT_ADDR(3, 230, RED), \
                                            DCC_PORT_ADDR(4, 230, GRN), \
                                            DCC_PORT_ADDR(5, 231, RED), \
                                            DCC_PORT_ADDR(6, 231, GRN), \
                                            DCC_PORT_ADDR(7, 232, RED), \
                                            DCC_PORT_ADDR(8, 232, GRN), \
                                            DCC_PORT_ADDR(9, 233, RED), \
                                            DCC_PORT_ADDR(10, 233, GRN), \
                                            DCC_PORT_ADDR(11, 234, RED), \
                                            DCC_PORT_ADDR(12, 234, GRN), \
                                            DCC_PORT_ADDR(13, 235, RED), \
                                            DCC_PORT_ADDR(14, 235, GRN), \
                                            DCC_PORT_ADDR(15, 236, RED), \
                                            DCC_PORT_ADDR(16, 236, GRN), \
                                            DCC_PORT_ADDR(17, 237, RED), \
                                            DCC_PORT_ADDR(18, 237, GRN), \
                                            DCC_PORT_ADDR(19, 238, RED), \
                                            DCC_PORT_ADDR(20, 238, GRN), \
                                            DCC_PORT_ADDR(21, 239, RED), \
                                            DCC_PORT_ADDR(22, 239, GRN), \
                                            DCC_PORT_ADDR(23, 240, RED), \
                                            DCC_PORT_ADDR(24, 240, GRN)
#endif

#ifndef LAST_USED_DCC_ADDR                                              // Must be set to the last used address
#define LAST_USED_DCC_ADDR                  DCC_CHKADDR(240, GRN)       // If wrong limmits are used an "warning: division by zero" will be generated
#endif

#ifndef STORE_DCC_SWITCHES_TO_EEPROM
#define STORE_DCC_SWITCHES_TO_EEPROM        1                           // Store the Switches for sound and light to the EEPROM
#endif




#ifndef  ENABLE_DPRINTF
#define  ENABLE_DPRINTF 0             // Enable the Dprintf() functions. Attention: This should be 0 in the release version to save memory (vfprintf uses 2368 bytes)
#endif

#ifndef WS281X_DATA_PIN                                                 // Test if it fits into the FLASH => YES it uses 8% => 95% FLASH used
#define WS281X_DATA_PIN                     -1                          // WS2812 LEDs, ...
#endif

#ifndef NUM_LEDS
#define NUM_LEDS                             5
#endif



//************************************************************************************************************

#if PORT_CNT > 80
  #error "Maximal port count 80 because of the EEPROM size"
  // 28 Bytes general data + 80*12 byte Port[] Array
#endif


#if USE_OLED == 0
  #undef  USE_LARGE_FONT_FOR_NUMBERS
  #define USE_LARGE_FONT_FOR_NUMBERS 0
  #undef  USE_u8x8
  #define USE_u8x8                   0
#endif

#if MOVE_STATUS_INVERS
  #define MOVE_STATUS_SET  FastPin<MOVE_STATUS_PIN>::lo()
  #define MOVE_STATUS_CLR  FastPin<MOVE_STATUS_PIN>::hi()
#else
  #define MOVE_STATUS_SET  FastPin<MOVE_STATUS_PIN>::hi()
  #define MOVE_STATUS_CLR  FastPin<MOVE_STATUS_PIN>::lo()
#endif

#if MOVING_FLASH_INVERS
  #define MOVING_FLASH_SET  FastPin<MOVING_FLASH_PIN>::lo()
  #define MOVING_FLASH_CLR  FastPin<MOVING_FLASH_PIN>::hi()
#else
  #define MOVING_FLASH_SET  FastPin<MOVING_FLASH_PIN>::hi()
  #define MOVING_FLASH_CLR  FastPin<MOVING_FLASH_PIN>::lo()
#endif



#include <limits.h>
#include <WString.h>
#include <EEPROM.h>
#include <avr/wdt.h>
#include <MobaTools.h>  // https://github.com/MicroBahner/MobaTools
#if USE_DCC
  #include <NmraDcc.h>
#endif

#include "Dprintf.h"
#include "Diagnose.h"

//#define ENCODER_OPTIMIZE_INTERRUPTS // This optional setting causes Encoder to use more optimized code. Unfortunately it doesn't work with the DCC library
#include <Encoder.h>                  // Rotary Encoder libraty from Paul Stoffregen (https://www.pjrc.com/teensy/td_libs_Encoder.html)

#define FASTLED_INTERNAL              // Disable version number message in FastLED library (looks like an error)
#include <FastLED.h>                  // FastPin

#if USE_OLED
  #include <U8g2lib.h>                // "U8g2" Library from Oliver Kraus
#endif

#define USE_AVDWEB_ANALOGREADFAST 1   // The standard Arduino analogRead() takes about 112us
#if USE_AVDWEB_ANALOGREADFAST         // This library takes 21us for one scan
  #include <avdweb_AnalogReadFast.h>  // The "AnalogScanner" which reads the values per interrupt uses to much memory: FLASH: 664, RAM: 115
#endif

#if USE_JQ6500_SERIAL
  #include "Smart_JQ6500_Serial.h"
#endif


/*
 Print Memory Usage:
 ~~~~~~~~~~~~~~~~~~~
 - Nach dieser Anleitung geht es: https://arduino.stackexchange.com/questions/31190/detailed-analyse-of-memory-usage
     cd C:\Program Files (x86)\Arduino\hardware\tools\avr\bin
     set elf_File=C:\Users\Hardi\AppData\Local\Temp\arduino_build_10229\Turntable.ino.elf
     RAM:
       avr-nm.exe -Crtd --size-sort "%elf_File%" | C:\Users\Hardi\AppData\Local\atom\app-1.28.0\resources\app.asar.unpacked\node_modules\dugite\git\usr\bin\grep.exe -i ' [dbv] ' | sort
     FLASH:
       avr-nm.exe -Crtd --size-sort "%elf_File%" | C:\Users\Hardi\AppData\Local\atom\app-1.28.0\resources\app.asar.unpacked\node_modules\dugite\git\usr\bin\grep.exe -i ' [tw] ' | sort

Attention: "printf" or "sprintf" uses a lot of memory:
   00000948 T vfprintf  = 2376 Byte
*/

MoToStepper Step1(10000, STEPDIR);
/*
 Spannung am Poti damit er sich bei voller Geschwindigkeit dreht:
 0.18V  Im Full   => Wird recht warm
 0.14V  Half Step


 Wenn die Stepper Versorgungsspannung unter 5.2V sinkt, dann funktioniert die Strom Regelung nicht mehr.
 Dann kann man das Poti auf 0 drehen und trotzdem fliesst noch 300mA => Der Stepper wird extrem Heiss ;-(

 MS1 MS2 MS3  Microstep Resolution Excitation Mode
  L   L   L   Full Step  2 Phase
  H   L   L   Half Step 1-2 Phase
  L   H   L   Quarter Step W1-2 Phase
  H   H   L   Eighth Step 2W1-2 Phase
  H   H   H   Sixteenth Step 4W1-2 Phase

 Es gibt ganz unterschiedliche Stepper Motoren mit der Bezeichnung 28BYJ-48
 https://www.kollino.de/arduino/schrittmotor-28byj-48/

 Mein Motor scheint ~32695 1/16 teil Schritte fuer eine Umdrehung haben.

 5.625°/64   => 4096 Steps/Umdr

 32695/16 = 2043.4375

 211627/16 = Eine Umdr.Scheibe

 Durchmesser der Scheibe 30 cm
 => Umfang = 942.5 mm
 => 1/8 Schritt = 0.00892 mm

 - Achtung: der "abs()" Befehl ist so definiert:
     #define abs(x) ((x)>0?(x):-(x))
   Das bedeutet, das der Ausdruck in der Klammer mehrfach berechnet wird
*/


#define SERIAL_BAUD                         9600        // Serial Baud rate (9600 Baud must be used if the JQ6500 sound module is used)

#ifndef DEBOUNCE_ZERO
#define DEBOUNCE_ZERO                       50          // Debouncing of the zero switch in mirco steps (500 was needed for the optical reflex detection)
#endif
#ifndef SPEED_POTI_MID_RANGE
#define SPEED_POTI_MID_RANGE                100         // Range of the speed poti which is 0  (Old 50)
#endif
#ifndef SPEED_POTI_CENTER
#define SPEED_POTI_CENTER                   512         // Center position of the speed poti (Normaly 512)
#endif

#ifndef ENABLE_ALWAYS_ON                                // Set to 1 for a powerful stepper without gearbox because the magnetic field will change the position when powered of
#define ENABLE_ALWAYS_ON                    0           // If a stepper driver like the TMC2100 is used it's better to disable the
#endif                                                  // NOT_ENABLE_PIN (-1) to activate the automatic power saving mode instead.

#ifndef ERR_FLASH_PERIOD
#define ERR_FLASH_PERIOD                    300
#endif
#ifndef MOVE_FLASH_PERIOD
#define MOVE_FLASH_PERIOD                   800
#endif

#ifndef STEPPS_STABLE_FACT
#define STEPPS_STABLE_FACT                  2           // Factor which is multiplied by the clearance to define the minimal steps to detect the zero position
#endif

#ifndef MENU_MAXLINES
#define MENU_MAXLINES                       4
#endif
#ifndef MENU_LEFT_BORDER
#define MENU_LEFT_BORDER                    8           // Used when USE_u8x8 is 0
#endif
#ifndef MENU_MAXCHAR
#define MENU_MAXCHAR                        16
#endif
#ifndef MENU_WIDTH
#define MENU_WIDTH                          128
#endif

#ifndef CLEARENCE_TEST_STEPS
  #if PORT_CNT <= 3                                                                                           // 24.01.21:
    #define CLEARENCE_TEST_STEPS (ee.StepsOneTurn / (3 * PORT_CNT)) // Number of steps used for the clearence test after the zero position is detected
  #else
    #define CLEARENCE_TEST_STEPS (ee.StepsOneTurn / PORT_CNT)       //   "
  #endif
#endif

#define UNDEF                               2000000000   // Undefined entry in Port_Pos[]

typedef struct ZeroDat_T
    {
    long ZeroPos0; // zero position 0->1 turning in positive direction
    long ZeroPos1; // zero position 1->0 turning in positive direction
    long ZeroNeg0; // zero position 0->1 turning in negative direction
    long ZeroNeg1; // zero position 1->0 turning in negative direction
    } ZeroDat_T ;

#define EE_VERSION_STR  "TurnTab"
#define EE_VER_NR       4
#define EE_CHECK_SIZE   sizeof(EE_VERSION_STR) + 1 + 1 // Version string + Ver_Nr + Port_Cnt

typedef struct
    {
    uint8_t Port_Pos_Init:1;
    uint8_t Is_Stopped:1;
    uint8_t Disable_Sound:1;
    uint8_t Light:1;
    } Flags_t;

typedef struct
    {
    char     Ver[sizeof(EE_VERSION_STR)];
    uint8_t  Ver_Nr;
    uint8_t  Port_Cnt;                // Is stored in the EEPROM to update the EEPROM in case the port cnt is changed
    long     StepsOneTurn;
    Flags_t  Flags;
    uint16_t Steps_Has_Contact;       // Number of steps until the geares have contact due to the clearance
    long     StepsLastDirChange;      // Used for HasContact()
    int8_t   OldDir = -1;             //   "
    long     ActStepps;               // Actual position
    int8_t   Act_Port;
    int8_t   Rev_Port;                // Turntable has been rotated from this port to the actual position -p-1 if pos has been corrected with the poti
    } EE_Data_T;

#define Port_Pos_Start  sizeof(EE_Data_T) // Start adress in the EEPROM for the Port_Pos[] data


//---------- Global Variables -------------

EE_Data_T ee;

uint32_t LEDTimer    = 0;
uint32_t ReadADTimer = 0;

uint16_t MovSpeed = MOVE_SPEED1;     // Speed used for the "Move_to_Port_or_Pos"
uint16_t ActSpeed;                   // Actual speed (Poti or "Move_to_Port_or_Pos")



#define  CMD_NONE            125     // Commands < CMD_NONE are the "move to Port" commands (-124 - +124)
#define  CMD_MOVE2STEP       126     // Move to a given position in steps
#define  CMD_MOVE_CONT       127     // Move continiously
int8_t   Command = CMD_NONE;         // Commands used after "TurnBackAndSetZero" is called
#define  Move_to_Port_Act    (Command < CMD_NONE)

#define  Move_Active         (Command != CMD_NONE)

#define  PORT_UNKNOWN        -127
#define  Rev_Port_Undefined  (ee.Rev_Port < 0)

Encoder  myEnc(ENCODER_A_PIN, ENCODER_B_PIN);
bool     SpeedPotiDisabled;

long     Dest_StepPos = UNDEF;
bool     Move_to_Contact_Point_is_Bussy = false;
uint32_t Delayed_Start_Moving = 0;

uint32_t EndTitelDispl;

#if USE_DCC
  NmraDcc  Dcc;                      // Dcc Accessory Decoder object
#endif

#if POLARISATION_RELAIS_PIN != -1
  const PROGMEM bool Polarisation[] = { POLARISATION_RELAIS_LIST };
  bool Polarisation_Releais_is_set_by_DCC = 0;
#endif

#if MOVE_STATUS_PIN != -1 || MOVING_FLASH_PIN != -1
  bool     Is_Moving         = false;
#endif

#if MOVING_FLASH_PIN != -1
  uint32_t Moving_Flash_Time = 0;
  #if MOVING_FLASH_MODE == 2
    uint8_t  Moving_Flash_State = 0;
  #endif
#endif

#if USE_JQ6500_SERIAL
    Smart_JQ6500_Serial mp3;
#else
    #if SOUND_PIN1 != -1
      uint32_t Time_to_Release_Sound1 = 0;
    #endif
    #if SOUND_PIN2 != -1
      uint32_t Time_to_Release_Sound2 = 0;
    #endif
    #if SOUND_PIN3 != -1
      uint32_t Time_to_Release_Sound3 = 0;
    #endif
    #if SOUND_PIN4 != -1
      uint32_t Time_to_Release_Sound4 = 0;
    #endif
#endif

#if SOUND_PIN1 != -1 || SOUND_PIN2 != -1 || USE_JQ6500_SERIAL // The sounds 3 & 4 are only played per DCC => They can't be disabled by DCC
    bool     Disable_Sound = 0;
#endif

#if WS281X_DATA_PIN >= 0
  CRGB leds[NUM_LEDS];
#endif


//----------- Forward definitions ---------------
int8_t CheckAndSetZero();


#if USE_OLED
  #if USE_u8x8 == 1 // only text outputs, saves 10% FLASH and and doesn't need RAM to store the display page
     #if OLED_TYP == 87
       U8X8_SSD1316_128X32_HW_I2C u8x(U8X8_PIN_NONE);                     // 0.87" Display
     #elif OLED_TYP == 91
       U8X8_SSD1306_128X32_UNIVISION_HW_I2C u8x(U8X8_PIN_NONE, SCL, SDA); // 0.91" Display
     #elif OLED_TYP == 96
       U8X8_SSD1306_128X64_NONAME_HW_I2C u8x(U8X8_PIN_NONE, SCL, SDA);    // 0.96" Display with 128x64 pixel
     #else
        #error "OLED_TYP not supported yet ;-("
     #endif
  #else
     #if ROTATE_DISPLAY_180_DEG
       #define U8G2_ROT U8G2_R2
     #else
       #define U8G2_ROT U8G2_R0
     #endif
     // Three possible display drivers. The differ in the used RAM. The first one uses a full frame buffer
     // => All data for the display fit into the RAM => The content for the display has to be drawn only once
     // The other drivers use less RAM => The display has to be drawn several times and written partly to the OLED
     // If several parts are used the OLED update time is longer ;-(
     #if OLED_TYP == 87 // 0.87" Display
       //U8G2_SSD1316_128X32_F_HW_I2C u8x(U8G2_ROT, U8X8_PIN_NONE); // Für 0.87" Display full frame buffer
         U8G2_SSD1316_128X32_1_HW_I2C u8x(U8G2_ROT, U8X8_PIN_NONE); // Für 0.87" Display
     #elif OLED_TYP == 91 // 0.91" Display
         // Rotate by 180 Deg: U8G2_R2 (Normal: U8G2_R0)    See: https://github.com/olikraus/u8g2/wiki/u8g2setupc
         U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8x(U8G2_ROT, U8X8_PIN_NONE); // 55-60 ms update time, full frame buffer:       512 bytes RAM (Times based on the Zugziehlanzeiger)
       //U8G2_SSD1306_128X32_UNIVISION_2_HW_I2C u8x(U8G2_ROT, U8X8_PIN_NONE); // 65-74 ms update time, 2 pages => 2* nextPage() 256 bytes RAM
       //U8G2_SSD1306_128X32_UNIVISION_1_HW_I2C u8x(U8G2_ROT, U8X8_PIN_NONE); // 88-94 ms update time, 4 pages => 4* nextPage() 128 bytes RAM
     #elif OLED_TYP == 96
        #error "OLED_TYP not supported by the u8g2 lib yet ;-("
     #else
        #error "OLED_TYP not supported yet ;-("
     #endif
  #endif
#endif

/*
 Änderung der Nummerierung / Drehrichtung der Scheibe
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Die Port Position  wird anders rum angezeigt. Intern bleibt es wie es ist
 Reverse:
 Int 0 1 2 3 .. 23 => Disp: 24 23 22 .. 1

 Normal:
 Int 0 1 2 3 .. 23 => Disp:  1 2 3 .. 24

 Außerdem muss das Poti und der Drehschalter getauscht werden
*/

//--------------------------------------
uint8_t Intern2DispPort(uint8_t IntPort)
//--------------------------------------
{
  #if TURNTABLE_DIRECTION == -1 // Reverse direction
    return PORT_CNT - IntPort;
  #else
    return IntPort + 1;
  #endif
}

//---------------------------------------
uint8_t Disp2InternPort(uint8_t DispPort)
//---------------------------------------
{
  #if TURNTABLE_DIRECTION == -1 // Reverse direction
    return PORT_CNT - DispPort;
  #else
    return DispPort - 1;
  #endif
}

//--------------
long Abs(long x)
//--------------
// The standard abs() function is defined lice this:
//   #define abs(x) ((x)>0?(x):-(x))
// => if x is a calculated expression the expression has to be calculated two times
{
  if (x >= 0)
     return x;
  return -x;
}

//------------
int Abs(int x)
//------------
{
  if (x >= 0)
     return x;
  return -x;
}

//------------------
int8_t Abs(int8_t x)
//------------------
{
  if (x >= 0)
     return x;
  return -x;
}


/*
27.12.20:
 4 Pages
   Der Sketch verwendet 23420 Bytes (72%) des Programmspeicherplatzes. Das Maximum sind 32256 Bytes.
   Globale Variablen verwenden 1011 Bytes (49%) des dynamischen Speichers, 1037 Bytes fÃ¼r lokale Variablen verbleiben. Das Maximum sind 2048 Bytes.

 full frame Buffer
   Der Sketch verwendet 23422 Bytes (72%) des Programmspeicherplatzes. Das Maximum sind 32256 Bytes.
   Globale Variablen verwenden 1395 Bytes (68%) des dynamischen Speichers, 653 Bytes fÃ¼r lokale Variablen verbleiben. Das Maximum sind 2048 Bytes.
                               -384
*/

#ifndef U8G_FONT_HEIGHT
#if USE_u8x8
  #define U8G_FONT_HEIGHT 1  // Positions are given in character position and not pixel
#else
  #define U8G_FONT_HEIGHT 8  // Must match with the used font
#endif
#endif

#if USE_u8x8 == 0
  #define print_Disp(Format, ...)     print_Disp_Proc(20,  F(Format), ##__VA_ARGS__)   // see: https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html
  #define print_DispY(y, Format, ...) print_Disp_Proc(y+7, F(Format), ##__VA_ARGS__)   // +7 because text positions are defined by the lower left point
#else
  #define print_Disp(Format, ...)     print_Disp_Proc(2,   F(Format), ##__VA_ARGS__)   // Positions are givein in characters and not pixel
  #define print_DispY(y, Format, ...) print_Disp_Proc(y/8, F(Format), ##__VA_ARGS__)   //
#endif

#if USE_u8x8 == 0
  #undef  NO_FLICKER_u8x8
  #define NO_FLICKER_u8x8 0
#endif

#if NO_FLICKER_u8x8
  //-----------------
  void Clear_to_Eol()
  //-----------------
  {
    uint8_t EndCol = u8x.getCols();
    while (u8x.tx < EndCol) u8x.print(' ');
  }

  //----------------------------
  void Clear_to_Line(uint8_t y0)
  //----------------------------
  {
    u8x.setCursor(0,0);
    while (u8x.ty < y0)
        {
        Clear_to_Eol();
        u8x.setCursor(0, u8x.ty+U8G_FONT_HEIGHT);
        }
  }

  //-----------------------
  void Clear_Rest_of_Disp()
  //-----------------------
  {
    uint8_t EndRow = u8x.getRows()-U8G_FONT_HEIGHT;
    do  {
        Clear_to_Eol();
        if (u8x.ty >= EndRow) break;
        u8x.setCursor(0, u8x.ty+U8G_FONT_HEIGHT);
        } while (1);
  }
#endif // NO_FLICKER_u8x8

//------------------------------------------------------------------
void print_Disp_Proc(uint8_t y0, const __FlashStringHelper *fmt, ...)
//------------------------------------------------------------------
// Simple printf like function which uses very little memory.
// It is called with one of the above defines.
// Special characters:
// - '#':  insert then next integer number and print it in the large font
//         if USE_LARGE_FONT_FOR_NUMBERS is enabled
//         Attention: The numbers are top alligned in USE_u8x8 and bottom alligned
//                    if USE_u8x8 is not used
// - '%':  insert then next integer number in the normal font
// - '\n': New line
{
  #if USE_OLED == 0
    #define OUT Serial
  #else
    #define OUT u8x
    #if USE_u8x8 == 1
      #if NO_FLICKER_u8x8
         Clear_to_Line(y0);
      #else
         u8x.clearDisplay();
      #endif
    #else
      u8x.firstPage();
    do {
    #endif
       uint8_t y = y0; // Text positions are defined by the lower left point
       u8x.setCursor(0, y);
  #endif
       va_list args;
       va_start(args, fmt);
       PGM_P p = reinterpret_cast<PGM_P>(fmt);
       while (1)
         {
         char c = pgm_read_byte(p++);
         if (c == '\0') break;
         #if USE_OLED
         if (c == '\n')
            {
            #if NO_FLICKER_u8x8
              Clear_to_Eol();
            #endif
            y+=U8G_FONT_HEIGHT;
            u8x.setCursor(0, y);
            }
         else if (c == '\t') { OUT.print(F("    ")); }
         else
         #endif
         if (c == '#' || c == '%')
              {
              #if USE_LARGE_FONT_FOR_NUMBERS
                 if (c == '#')
                    {
                    #if NO_FLICKER_u8x8
                       u8x.ty-=U8G_FONT_HEIGHT;
                    #endif
                    u8x.setFont(LARGE_FONT_FOR_NUMBERS);
                    }
              #endif
              int i = va_arg(args, int);
              OUT.print(i);
              #if USE_LARGE_FONT_FOR_NUMBERS
                 u8x.setFont(NORMAL_FONT);
                 #if NO_FLICKER_u8x8
                     if (c == '#') u8x.ty+=U8G_FONT_HEIGHT;
                 #endif
              #endif

              }
         else OUT.print(c);
         }
       va_end(args);

  #if USE_OLED
       CheckAndSetZero();   // To be able to display something while the stepper is moving
       #if USE_u8x8 == 0
       } while ( u8x.nextPage() );
       #endif
       #if NO_FLICKER_u8x8
         Clear_Rest_of_Disp();
       #endif
  #else
    OUT.print('\n');
  #endif
}

//---------------------------------------------------------------------------
void Display_Menu(const __FlashStringHelper *Menu, int8_t Top, int8_t ActPos)
//---------------------------------------------------------------------------
// The menu is represented by a text string with several lines which are separated by '\n'
// Top and ActPos start with 1
{
  #if USE_OLED == 0
    #define OUT Serial
  #else
    #define OUT u8x
    #if USE_u8x8 == 1
      uint8_t x = MENU_MAXCHAR;
      int8_t  y = -U8G_FONT_HEIGHT;
      #if NO_FLICKER_u8x8 == 0
        u8x.clearDisplay();
      #endif
    #else
    u8x.firstPage();
    do {
       uint8_t y = -1;  // "-1" to show also the bottom line of the "g"
    #endif
  #endif
       uint8_t LineNr = 0;
       char c = '\n'; // Start with a new line to simplyfy the code
       PGM_P p = reinterpret_cast<PGM_P>(Menu);
       while (1)
         {
         if (c == '\0') break;
         if (c == '\n')
              {
              LineNr++;
              if (LineNr >= Top)
                 {
                 if (LineNr - Top >= MENU_MAXLINES) break;
                 #if USE_OLED
                     #if USE_u8x8 == 1
                       while (x++ < MENU_MAXCHAR) OUT.print(F(" ")); // Clear old characters / draw invers
                       u8x.setInverseFont(LineNr == ActPos);
                     #else
                       if (LineNr == ActPos)
                            {
                            u8x.drawBox(0, y, MENU_WIDTH, U8G_FONT_HEIGHT); // Pos = Top left corner
                            u8x.setDrawColor(0);
                            }
                       else u8x.setDrawColor(1);
                     #endif
                   y+=U8G_FONT_HEIGHT;
                   #if USE_u8x8 == 1
                     u8x.setCursor(0, y); // Pos = bottom left corner
                     OUT.print(F(" "));
                     x = 1;
                   #else
                     u8x.setCursor(MENU_LEFT_BORDER, y); // Pos = bottom left corner
                   #endif
                 #else
                   Serial.println(F(""));
                   Serial.print(LineNr == ActPos? '>':' ');
                 #endif
                 }
              }
         else {
              if (LineNr >= Top)
                 {
                 OUT.print(c);
                 #if USE_u8x8 == 1
                   x++;
                 #endif
                 }
              }
         c = pgm_read_byte(p++);
         }
  #if USE_OLED
    #if USE_u8x8 == 1
       while (x++ < MENU_MAXCHAR) OUT.print(F(" "));
       u8x.setInverseFont(0);
    #else
       } while ( u8x.nextPage() );
    u8x.setDrawColor(1);
    Clear_Rest_of_Disp();
    #endif
  #else
    OUT.print('\n');
  #endif
}


//--------------------------------------------------------
int8_t Check_Rotary_Encoder(void(*Callback)(int8_t Delta))
//--------------------------------------------------------
{
  static int8_t oldPosition = 0;
  int32_t enc = ROTATIONSWITCH_DIRECTION * myEnc.read();
  int8_t Delta = 0;
  int8_t Offs;
  if (enc > 0)
       Offs = +2;
  else Offs = -1;
  int8_t newPosition = (Offs + enc) / 4;
  // Each step generates 4 counts. Unfortunately the first and last counts have a jidder
  // Therefore Offs is added to improve this:
  // enc Offs  +Offs newPosition
  // ~~~ ~~~~  ~~~~~ ~~~~~~~~~~~
  // -7   -1    -8   -2
  // -6   -1    -7   -1
  // -5   -1    -6   -1
  // -4   -1    -5   -1
  // -3   -1    -4   -1
  // -2   -1    -3    0
  // -1   -1    -2    0
  //  0   +2     2    0
  //  1   +2     3    0
  //  2   +2     4    1
  //  3   +2     5    1
  //  4   +2     6    1
  //  5   +2     7    1
  //  6   +2     8    2
  //  7   +2     9    2
  //  8   +2     10   2
  if (newPosition != oldPosition)
       {
       Delta = newPosition - oldPosition;
       oldPosition = newPosition;
       EndTitelDispl = 0;
       if (Callback) Callback(Delta);
       }
  /*
  static int32_t  OldEnc = 0;
  if (OldEnc != enc)
     {
     Dprint2("Enc:", enc); Dprintln2(" newPosition:", newPosition);
     OldEnc = enc;
     }
  */
  return Delta;
}


//---------------------------
bool Encoder_Button_Pressed()
//---------------------------
{
  #if ENCODER_SW_PIN == A0 || ENCODER_SW_PIN == A1 || ENCODER_SW_PIN == A2 || ENCODER_SW_PIN == A3 || ENCODER_SW_PIN == A4 || ENCODER_SW_PIN == A5 || ENCODER_SW_PIN == A6 || ENCODER_SW_PIN == A7
    #if USE_AVDWEB_ANALOGREADFAST
      uint16_t Value = analogReadFast(ENCODER_SW_PIN);
    #else
      uint16_t Value = analogRead(ENCODER_SW_PIN);
    #endif
    return Value < 512;
  #else
    return digitalRead(ENCODER_SW_PIN) == 0;
  #endif
}

//----------------------------------------------------------------------------------------------------
int8_t Proc_Menu(int8_t &ActPos, uint8_t FirstPos, const __FlashStringHelper *Menu, uint8_t MenuItems)
//----------------------------------------------------------------------------------------------------
// FirstPos could be used to show head lines which could not be selected
// Normaly FirstPos = 1
{
  int8_t Top = 1;
  while (1)
    {
    if (ActPos > MenuItems) ActPos = MenuItems;
    if (ActPos < FirstPos) ActPos = FirstPos;
    if (ActPos - Top >= MENU_MAXLINES) Top = ActPos - MENU_MAXLINES + 1;
    if (ActPos < Top) Top = ActPos;
    Display_Menu(Menu, Top, ActPos);
    while (Encoder_Button_Pressed())    // Wait until the switch is released after the display is shown
       {
       delay(100);
       Check_Rotary_Encoder(NULL);      // Prevent wrong position when the button is released
       }
    while (1)
        {
        Update_Moving_Status();
        if (Encoder_Button_Pressed())
           {
           while (Encoder_Button_Pressed()); // Wait until the switch is released
           return ActPos; // Button pressed ?
           }

        int8_t Delta = Check_Rotary_Encoder(NULL);
        if (Delta)
           {
           ActPos += Delta * ROTATIONSWITCH_MENU_DIR;
           break;
           }
        }
    }
}

//--------------
void Test_Menu()
//--------------
{
/*
  int8_t ActPos = 0;
  Dprintf("Menu: %i\n",
  Proc_Menu(ActPos, 1,
            F("Menu1\n"
              "Menu2\n"
              "Menu3\n"
              "Menu4\n"
              "Menu5\n"
              "Menu6\n"
              "Menu7"), 7));
*/
}


//-----------------
void Write_EEPROM()
//-----------------
// Write the changed bytes to the EEPROM
{
  //DprintlnT("Writing EEPROM");
  if (ee.Flags.Is_Stopped)
     ee.ActStepps = Step1.readSteps();
  uint8_t *p = (uint8_t*)&ee;
  for (uint16_t Addr = 0; Addr < sizeof(EE_Data_T); Addr++, p++)
      {
      EEPROM.update(Addr, *p);
      }
}
  //-------------------------------------
  int Get_EE_Adr(uint8_t Dir, uint8_t Nr)
  //-------------------------------------
  {
    return Port_Pos_Start + (Dir * PORT_CNT + Nr)*sizeof(long);
  }

  //-----------------------------------------
  long Read_Port_Pos(uint8_t Dir, uint8_t Nr)
  //-----------------------------------------
  {
    long Val;
    int Adr = Get_EE_Adr(Dir, Nr);
    EEPROM.get(Adr, Val);
    return Val;
  }

  //----------------------------------------------------
  void Write_Port_Pos(uint8_t Dir, uint8_t Nr, long Val)
  //----------------------------------------------------
  {
    int Adr = Get_EE_Adr(Dir, Nr);
    for (uint8_t i = 0; i < 4; i++, Adr++)
        {
        EEPROM.update(Adr, Val & 0xFF);
        Val >>= 8;
        }
  }

//----------------
void Read_EEPROM()
//----------------
{
  strcpy(ee.Ver, EE_VERSION_STR);
  ee.Ver_Nr       = EE_VER_NR;
  ee.Port_Cnt     = PORT_CNT;  // Is stored in the EEPROM to update the EEPROM in case the port cnt is changed
  ee.StepsOneTurn = UNDEF;
  ee.Act_Port     = PORT_UNKNOWN;
  ee.Rev_Port     = PORT_UNKNOWN;
  memset(&ee.Flags, 0, sizeof(Flags_t));

  uint8_t *p = (uint8_t*)&ee;
  uint8_t b;
  uint16_t Addr;

  for (Addr = 0; Addr < sizeof(EE_Data_T); Addr++, p++)
    {
    b = EEPROM.read(Addr);
    if (Addr < EE_CHECK_SIZE)
         {
         //Dprintf("%i %c=%02X %02X\n", Addr, b<' ' ? '?':b, b, *p); // Debug
         if (b != *p)
            {
            //Dprintf("Writing EEPROM defaults (Head Err @%i)\n", Addr); // Debug
            Write_EEPROM();
            for (uint8_t i = 0; i < PORT_CNT*(2+(USE_3_PORT_POS?1:0)); i++)
              {
              Write_Port_Pos(0, i, UNDEF);
              }
            break;
            }
         }
    else *p = b;
    }

   #if 1 && ENABLE_DPRINTF // Debug
    if (Addr == sizeof(EE_Data_T)) DprintlnT("EE Data read");
    for (uint8_t i = 0; i < PORT_CNT; i++)
        #if USE_3_PORT_POS
          { Dprint2("Port[", Intern2DispPort(i)); Dprint2("]=", Read_Port_Pos(0, i)); Dprint2(" ", Read_Port_Pos(1, i)); Dprintln2(" ", Read_Port_Pos(2, i)); }
        #else
          { Dprint2("Port[", Intern2DispPort(i)); Dprint2("]=", Read_Port_Pos(0, i)); Dprintln2(" ", Read_Port_Pos(1, i)); }
        #endif
   #endif
   if (ee.Flags.Is_Stopped)
      {
      Step1.setZero(-ee.ActStepps);  // ToDo: Hier gehen u.U. Schritte verloren weil der A4988 mit 0 beginnt obwohl er vorher auf 15/16 Stand
      //Dprintln2("Position Restored: ", Step1.readSteps());
      }
}

//----------------
bool Get_Zero_SW()
//----------------
{
  return !digitalRead(ZERO_SW_PIN); // "!" because it's Low active
}

#if USE_JQ6500_SERIAL
  //-------------------------
  void Play_Sound(uint8_t Nr)
  //-------------------------
  {
    mp3.playFileByIndexNumber(Nr);
  }

#else // not USE_JQ6500_SERIAL

  #define PLAY_SOUND_NR(Nr)                                                      \
               {                                                                 \
               FastPin<SOUND_PIN##Nr>::setOutput();                              \
               Time_to_Release_Sound##Nr = millis() + SOUND_ACT_DURATION;        \
               }

  //-------------------------
  void Play_Sound(uint8_t Nr)
  //-------------------------
  {
    switch (Nr)
        {
        #if SOUND_PIN1 != -1
        case 1: PLAY_SOUND_NR(1); break;
        #endif
        #if SOUND_PIN2 != -1
        case 2: PLAY_SOUND_NR(2); break;
        #endif
        #if SOUND_PIN3 != -1
        case 3: PLAY_SOUND_NR(3); break;
        #endif
        #if SOUND_PIN4 != -1
        case 4: PLAY_SOUND_NR(4); break;
        #endif
        }
  }
#endif

/*
 Überlegungen                           10.12.20:
 ~~~~~~~~~~~~
 es gibt 4 verschieden Signale vom Zero Switch

 Drehrichtung   Flanke
 Positiv        0->1     (bei mir Uhrzeigersinn)
 Positiv        1->0
 Negativ        0->1     (bei mir gegen den Uhrzeigersinn)
 Negativ        1->0

 Wenn sich der Motor in einer Richtung dreht und eine 0->1 und eine 1->0 Flanke
 erkannt wird, dann kann man die Länge die der Nullpunktschalter aktiv ist bestimmen.
 Diese Länge wird im Programm ZeroSteps genannt.

 Wenn die Scheibe zurück gedreht wird, dann kommen die Markierungen bedingt durch
 Spiel der Zahnräder später.

              ZeroSteps

             ,----->----,
             |          |
     --->----'          '--->----------
           ZeroPos0     ZeroPos1
                                        Richtung umkehren
        ,-----<----,    :
        |          |    :
     -<-'          '---<---------------
      ZeroNeg1   ZeroNeg0
                   :    :
                  Clearance

 Die Eignetliche Null Markierung ist die ZeroPos0.

 Wird eine Position im positiver Richtung angefahren, dann können die Positionen direkt
 angegeben werden.
 Wenn die Scheibe in negativer Richtung gedreht wird, dann muss "Clearance" von der
 Sollposition abgezogen werden.

 Wann soll der Nullpunkt gesetzt werden?
 - Ein mal zu Begin?
 - Jedes mal wenn möglich
 - Nur bei positiver Drehrichtung
 - Soll der Nullpunkt in die Mitte zwischen ZeroPos0 und ZeroPos1 gelegt werden
   zum ausgleichen von Messfehlern
 - !! Der Nullpunkt muss spätestens nach einer Umdrehung auf 0 gesetzt werden  !!
   !! sonst addieren sich die Fehler bei der Messung der gesammt Schrittanzahl !!
 - Wenn sich die Scheibe per Poti bewegt, dann wird der Nullpunkt bei positiver
   Drehrichtung automatisch gesetzt. Wenn sich die Scheibe rückwärts dreht, dann
   muss sie angehalten werden und genullt werden.


 Wenn der Stepper Schritte verliert, dann ist es besser wenn der Nullpunkt immer
 wieder neu gesetzt wird. Aber eigentlich sollte das nicht auftreten denn sonst
 kann die Scheibe nicht längere Zeit ohne neuen Abgleich benutzt werden.
 Es wäre gut, wenn eine Fehlermeldung generiert wird wenn die Abweichung zu groß ist.

 Der Nullpunkt muss jedes mal neu gesetzt werden damit die Schrittzähler nicht überläuft.

 Man könnte den Nullpunkt zu Begin mehrfach messen und den durchschnittlichen
 Wert verwenden. Das gleiche gilt für "ZeroSteps" und "Clearance".
 Das könnte man auch mit verschiedenen Geschwindigkeiten machen.

 Es sollte auch eine Umdrehung gemessen werden damit man die Auflösung (Stepps/Grad)
 berechnen kann.

 Die Daten werden im EEPROM Gespeichert

 => Function
*/



//---------------------------------
void Set_Moving_Status(bool Moving)
//---------------------------------
{
  #if MOVE_STATUS_PIN != -1 || MOVING_FLASH_PIN != -1 || SOUND_PIN1 != -1 || SOUND_PIN2 != -1 || USE_JQ6500_SERIAL
    if (Is_Moving != Moving)
       {
       Is_Moving = Moving;
       //Dprintln2("Status:", Moving);
  #endif

       #if MOVE_STATUS_PIN != -1
         if (Moving)
              MOVE_STATUS_SET;
         else MOVE_STATUS_CLR;
       #endif

       #if MOVING_FLASH_PIN != -1
            if (Moving)
                 {
                   Moving_Flash_Time  = millis();
                   #if MOVING_FLASH_MODE == 2
                     Moving_Flash_State = 0;
                   #else
                     MOVING_FLASH_SET;
                   #endif
                 }
            else { MOVING_FLASH_CLR; }
       #endif

       #if SOUND_PIN1 != -1 || SOUND_PIN2 != -1 || USE_JQ6500_SERIAL
         uint8_t Mode;
         //Dprint2("Moving:", Moving); Dprint2(" SOUND_MODE1:", SOUND_MODE1); Dprint2(" Disable_Sound:", Disable_Sound); Dprintln2(" Command:", Command);
         if (Moving)
              Mode = 1; // started
         else Mode = 2; // stopped
       #endif
       #if SOUND_PIN1 != -1  || USE_JQ6500_SERIAL
         if ((Mode & SOUND_MODE1) && Disable_Sound == 0 && (SOUND_POTI_MOVE || (Command != CMD_NONE && Command != CMD_MOVE_CONT)))
            {
            Play_Sound(SOND1_FILENR);
            #if DELAY_TURN_START_SOUND
               if (Mode == 1) Delayed_Start_Moving = millis() + DELAY_TURN_START_SOUND;
            #endif
            }
       #endif

       #if SOUND_PIN2 != -1  || USE_JQ6500_SERIAL
         if ((Mode & SOUND_MODE2) && Disable_Sound == 0 && (SOUND_POTI_MOVE || (Command != CMD_NONE && Command != CMD_MOVE_CONT)))
            {
            Play_Sound(SOND2_FILENR);
            #if DELAY_TURN_START_SOUND
               if (Mode == 1) Delayed_Start_Moving = millis() + DELAY_TURN_START_SOUND;
            #endif
            }
       #endif

  #if MOVE_STATUS_PIN != -1 || MOVING_FLASH_PIN != -1 || SOUND_PIN1 != -1 || SOUND_PIN2 != -1 || USE_JQ6500_SERIAL
       }
  #endif
}

//-------------------------
void Update_Moving_Status()
//-------------------------
{
  #if MOVING_FLASH_PIN != -1
    if (Is_Moving)
       {
       #if MOVING_FLASH_MODE == 1
           // ,----,
           // |    |
           // '    '----
           //   T1   T1
           uint32_t t = millis();
           if (t - Moving_Flash_Time >= MOVING_FLASH_TIME1)
              {
              Moving_Flash_Time = t;
              if (digitalRead(MOVING_FLASH_PIN) != MOVING_FLASH_INVERS)
                   MOVING_FLASH_CLR;
              else MOVING_FLASH_SET;
              }
       #endif

       #if MOVING_FLASH_MODE == 2
           // ,-,   ,-,
           // | |   | |
           // ' '---' '---------
           // T1 T2    T3
           static uint16_t Time;
           uint32_t t = millis();
           if (t - Moving_Flash_Time >= Time || Moving_Flash_State == 0)
              {
              Moving_Flash_Time = t;
              switch (Moving_Flash_State)
                {
                case 0:  // Initialisation
                case 1:  MOVING_FLASH_SET; Time = MOVING_FLASH_TIME2_1; break;
                case 2:  MOVING_FLASH_CLR; Time = MOVING_FLASH_TIME2_2; break;
                case 3:  MOVING_FLASH_SET; Time = MOVING_FLASH_TIME2_1; break;
                default: MOVING_FLASH_CLR; Time = MOVING_FLASH_TIME2_3; Moving_Flash_State = 0; break;
                }
              Moving_Flash_State++;
              }
       #endif
       }
  #endif

  #if SOUND_PIN1 != -1 && USE_JQ6500_SERIAL == 0
    if (Time_to_Release_Sound1 && millis() >= Time_to_Release_Sound1)
       {
       FastPin<SOUND_PIN1>::setInput();
       Time_to_Release_Sound1 = 0;
       }
  #endif
  #if SOUND_PIN2 != -1 && USE_JQ6500_SERIAL == 0
    if (Time_to_Release_Sound2 && millis() >= Time_to_Release_Sound2)
       {
       FastPin<SOUND_PIN2>::setInput();
       Time_to_Release_Sound2 = 0;
       }
  #endif
  #if SOUND_PIN3 != -1 && USE_JQ6500_SERIAL == 0
    if (Time_to_Release_Sound3 && millis() >= Time_to_Release_Sound3)
       {
       FastPin<SOUND_PIN3>::setInput();
       Time_to_Release_Sound3 = 0;
       }
  #endif
  #if SOUND_PIN4 != -1 && USE_JQ6500_SERIAL == 0
    if (Time_to_Release_Sound4 && millis() >= Time_to_Release_Sound4)
       {
       FastPin<SOUND_PIN4>::setInput();
       Time_to_Release_Sound4 = 0;
       }
  #endif
}

//---------------------------------
void Switch_Var(bool &Var, bool On)
//---------------------------------
{
  Var = On;
}

//------------------------
void Switch_Sound(bool On)
//------------------------
{
  #if SOUND_PIN1 != -1 || SOUND_PIN2 != -1 || USE_JQ6500_SERIAL
    Switch_Var(Disable_Sound, On);
    #if STORE_DCC_SWITCHES_TO_EEPROM
        ee.Flags.Disable_Sound = On;
        Write_EEPROM();
    #endif
  #endif
}

//------------------------
void Switch_Light(bool On)
//------------------------
{
  #if DCC_ENABLE_LIGHT_ADDR != -1 || DCC_DISABLE_LIGHT_ADDR != -1
      if (On)
           FastPin<LIGHT_PIN>::hi();
      else FastPin<LIGHT_PIN>::lo();
      #if STORE_DCC_SWITCHES_TO_EEPROM
          ee.Flags.Light = On;
          Write_EEPROM();
      #endif
  #endif
}

//-------------------------
void Restore_DCC_Switches()
//-------------------------
{
  #if STORE_DCC_SWITCHES_TO_EEPROM
    Disable_Sound = ee.Flags.Disable_Sound;
    Switch_Light(ee.Flags.Light);
  #endif
}

//--------------------
void Flash_StatusLED()
//--------------------
{
  if (millis() > LEDTimer)
     {
     LEDTimer += MOVE_FLASH_PERIOD/2;
     FastPin<STATUS_LED_PIN>::toggle();
     }
}


//---------------------------------
void WaitforNStepps(uint16_t Steps)
//---------------------------------
{
  long ActPos = Step1.readSteps();
  while(Step1.moving() && Abs(Step1.readSteps() - ActPos) < Steps)
    Flash_StatusLED();
}

//------------------------------
void WaitforZeroSwitch(bool val)
//------------------------------
{
  //DprintT("WaitforZeroSwitch:"); DprintA(val); DprintT(" ");
  while (Get_Zero_SW() != val) Flash_StatusLED();
}

//----------------------------------
void WaitforZeroSwitch_and_SetZero()
//----------------------------------
{
  WaitforZeroSwitch(1);
  Step1.setZero();
}

//-------------------------------------------------
long WaitforZeroSwitch_readSteps_Debounce(bool val)
//-------------------------------------------------
{
  long steps;
  WaitforZeroSwitch(val);
  steps = Step1.readSteps();

  WaitforNStepps(DEBOUNCE_ZERO);

  /*
  if (Get_Zero_SW() != val) // Uses 214 Byte
     {
     //Dprintf("Error: DEBOUNCE_ZERO to long %i %i\n", Get_Zero_SW(), val);
     Step1.rotate(0);
     WaitUntilStopped(true);
     LEDTimer.setBasetime(ERR_FLASH_PERIOD/2);
     while (1)
        Flash_StatusLED();
     }
  */
  return steps;
}
/*
 Mit Interrupt:
 Repeat_Z: 0.02 ZStep: 5.76 5.59 Clearence: 8.69 8.51
 Repeat_Z: -0.03 ZStep: 5.83 5.59 Clearence: 8.69 8.45 8.46 8.70

 Repeat_Z: 0.02 ZStep: 5.78 5.60 Clearence: 8.68 8.50
 Repeat_Z: -0.01 ZStep: 5.83 5.60 Clearence: 8.69 8.46 8.47 8.70

 Repeat_Z: 0.02 ZStep: 5.80 5.59 Clearence: 8.70 8.50
 Repeat_Z: 0.00 ZStep: 5.83 5.60 Clearence: 8.72 8.49 8.48 8.72

 Ohne Interrupt:
 Repeat_Z: 0.02 ZStep: 5.80 5.59 Clearence: 8.72 8.52
 Repeat_Z: 0.00 ZStep: 5.83 5.60 Clearence: 8.72 8.50 8.50 8.73

 Repeat_Z: -0.11 ZStep: 5.71 6.01 Clearence: 8.43 8.73
 Repeat_Z: -0.09 ZStep: 5.70 5.99 Clearence: 8.43 8.72 8.74 8.44

 Repeat_Z: -0.19 ZStep: 5.71 5.78 Clearence: 8.48 8.55
 Repeat_Z: -0.18 ZStep: 5.70 5.79 Clearence: 8.49 8.58 8.56 8.48

 Steps for one turn:105747 (Old: 105806)   Immer abwechselnd klein/groß ???
 Steps for one turn:105781 (Old: 105747)
 Steps for one turn:105740 (Old: 105781)
 Steps for one turn:105802 (Old: 105740)
 Steps for one turn:105733 (Old: 105802)
 Steps for one turn:105766 (Old: 105733)
 Power abgeklemmt zwischen den Tests :
 Steps for one turn:105763 (Old: 105766)
 Steps for one turn:105730 (Old: 105763)
 Steps for one turn:105805 (Old: 105730)


 Messung einer Umdrehung per interrupt. Dabei hat sich die Scheibe mit konstanter
 geschwindigkeit gedreht und es wurde bei einer Flanke die Stepps ermittelt und auf 0 gesetzt
 ZeroStep:105824
 ZeroStep:105712
 ZeroStep:105771
 ZeroStep:105724
 ZeroStep:105753
 ZeroStep:105765
 ZeroStep:105752

 Gleiche Messung ohne interrupt:
 Hier wurde die normale funktion zum setZoro nach einer Umdrehung benutzt
  Zero dif: 105767 (942.73 mm)
  Zero dif: 105770 (942.76 mm)
  Zero dif: 105780 (942.85 mm)
  Zero dif: 105773 (942.79 mm)
  Zero dif: 105781 (942.86 mm)
  Zero dif: 105769 (942.75 mm)
  Zero dif: 105783 (942.87 mm)
  Zero dif: 105738 (942.47 mm)
  Zero dif: 105792 (942.95 mm)
  Zero dif: 105727 (942.38 mm)
  Zero dif: 105796 (942.99 mm)
  Zero dif: 105752 (942.60 mm)
  Zero dif: 105768 (942.74 mm)
  Zero dif: 105752 (942.60 mm)
*/


//-------------------------------
void Clearence_Test(ZeroDat_T &z)
//-------------------------------
//
//                  ZeroSteps
//                 ,----->----,
//                 |          |
//     ------->----'          '--->------
//               ZeroPos0     ZeroPos1
//                                        Richtung umkehren
//            ,-----<----,    :
//            |          |    :
//     -----<-'          '---<-----------
//          ZeroNeg1   ZeroNeg0
//                       :    :
//                      Clearance
{
  uint16_t TestSpeed  = CLEARENCE_TEST_SPEED;           // Maximal speed = 25000 [Steps/10sek]
  Step1.rotate(1);                                      // Move in the positive direction
  Step1.setSpeedSteps(TestSpeed);
//Dprintf("Start Clearence_Test\n");
  z.ZeroPos0 = WaitforZeroSwitch_readSteps_Debounce(1); // Wait until the zero switch is activated
  z.ZeroPos1 = WaitforZeroSwitch_readSteps_Debounce(0); // Wait until the zero switch is released
  Step1.doSteps((long)CLEARENCE_TEST_STEPS);            // Move a little bit further
  WaitUntilStopped(false);
  delay(500); // ToDo: Is this necessary ?

//Dprintf("Rotate in other dir\n");
  Step1.rotate(-1);                                     // Move in the other direction
  Step1.setSpeedSteps(TestSpeed);
  z.ZeroNeg0 = WaitforZeroSwitch_readSteps_Debounce(1); // Wait until the zero switch is activated
  z.ZeroNeg1 = WaitforZeroSwitch_readSteps_Debounce(0); // Wait until the zero switch is released

  Step1.doSteps((long)-CLEARENCE_TEST_STEPS);           // Move a little bit further
  WaitUntilStopped(false);
  delay(500); // ToDo: Is this necessary ?
//Dprintf("End Clearence_Test\n");
}

//---------------------------
float Steps_to_mm(long Steps)
//---------------------------
{
  return (float)Steps * CIRCUMFERENCE / ee.StepsOneTurn ;
}

//------------------
void Auto_Calibrate()
//------------------
// Calibrates the zero position the clearence and some other parameter of the stepper
{
  ee.Flags.Is_Stopped = 0;
  Write_EEPROM();
  //          1234567890123456
  print_Disp(" Calibrating...");

  uint16_t CalSpeed = CALIBRATE_SPEED;   // Maximal speed = 25000 [Steps/10sek]

  Set_Moving_Status(1);
  Step1.rotate(1);
  Step1.setSpeedSteps(CalSpeed);

  if (Get_Zero_SW())                          // If the zero switch is achtive => Move until it's released
     WaitforZeroSwitch_readSteps_Debounce(0); // Wait until the zero switch is released

  // *** Set the zero position ***
  //DprintlnT("Searching the zero position...");
  WaitforZeroSwitch_and_SetZero();

  if (ee.StepsOneTurn == UNDEF || ALLWAYS_CHECK_STEPS_ONE_TURN)
     {
     // *** Get the total number of steps ***
     //long Old_StepsOneTurn = ee.StepsOneTurn;
     WaitforZeroSwitch_readSteps_Debounce(1);    // Debouncing
     WaitforZeroSwitch_readSteps_Debounce(0);    // Wait until the switch is 0
     //DprintlnT("Rotate one turn to get the total number of steps");

     WaitforZeroSwitch(1);                       // Rotate one turn until the switch is active again
     ee.StepsOneTurn = Step1.readSteps();
     Step1.setZero();

     //Dprintln2("Steps for one turn:", ee.StepsOneTurn);
     Step1.doSteps((long)-CLEARENCE_TEST_STEPS); // Move back (For debugging)
     WaitUntilStopped(false);
     }

  ZeroDat_T z;
  //long ZeroSum = 0;
  //long OldZeroNeg0, OldZeroNeg1;
  //long NegOffsSum = 0;
  uint8_t Cl_Test_Cnt = 2;
  long Steps_Has_Contact_Sum = 0;
  for (uint8_t i = 0; i < Cl_Test_Cnt; i++)
    {
    Clearence_Test(z);
    //ZeroSum    += z.ZeroPos0;
    //NegOffsSum += z.ZeroNeg0 - z.ZeroPos0;            // Diference to the zero pos in negative direction for debugging
    Steps_Has_Contact_Sum += z.ZeroPos1 - z.ZeroNeg0;

    //                  ZeroSteps
    //                 ,----->----,
    //                 |          |
    //     ------->----'          '--->------
    //               ZeroPos0     ZeroPos1
    //                                        Richtung umkehren
    //            ,-----<----,    :
    //            |          |    :
    //     -----<-'          '---<-----------
    //          ZeroNeg1   ZeroNeg0
    //            :    :     :    :
    //          Clearance   Clearance
    #if 0
      //Dprintf("%li %li ", z.ZeroPos1 - z.ZeroNeg0, z.ZeroPos0 - z.ZeroNeg1);
      DprintT("Repeat_Z: "); DprintA(Steps_to_mm(z.ZeroPos0)); DprintT(" ");

      DprintT("ZStep: ");
      DprintA(Steps_to_mm(z.ZeroPos1 - z.ZeroPos0), 2); DprintT(" ");
      DprintA(Steps_to_mm(z.ZeroNeg0 - z.ZeroNeg1), 2); DprintT(" ");

      DprintT("Clearence: ");
      DprintA(Steps_to_mm(z.ZeroPos1 - z.ZeroNeg0), 2); DprintT(" ");
      DprintA(Steps_to_mm(z.ZeroPos0 - z.ZeroNeg1), 2); DprintT(" ");
      //if (i>0)
      //   {
      //   DprintA(Steps_to_mm(z.ZeroPos0 - OldZeroNeg1), 2); DprintT(" ");
      //   DprintA(Steps_to_mm(z.ZeroPos1 - OldZeroNeg0), 2); DprintT(" ");
      //   }
      //Dprintln2(" Repeat Z: ", z.ZeroPos0);
      DprintlnT("");
      //OldZeroNeg0 = z.ZeroNeg0;
      //OldZeroNeg1 = z.ZeroNeg1;
    #endif
    }
  /*
  // Correct the zero position
  Corr_Zero = ZeroSum / Cl_Test_Cnt;
  Dprintf("Pos: %li Correct Zero: %li\n", Step1.readSteps(), Corr_Zero);
  Step1.setZero(Corr_Zero - Step1.readSteps());
  Dprintf("New Pos: %li\n", Step1.readSteps());
  */

  //NegZeroOffs = NegOffsSum / Cl_Test_Cnt;    // Offset to zero when moving in negative direction
  ee.Steps_Has_Contact = Steps_Has_Contact_Sum / Cl_Test_Cnt;
  FastPin<STATUS_LED_PIN>::lo();
  Write_EEPROM();
  ee.Act_Port = ee.Rev_Port = PORT_UNKNOWN;
}

#if USE_DCC

#define ADD_DCC_ADDR_CNT  30  // Number of additional DCC Channels

// Accessory Decoder Extended (14 Bit): Addresshttps://dccwiki.com/Address_Range
// The list contains the address and the direction:
//   Addr * 2 + Dir
// This uses 15 bits
// -1 is used to disable an entry
const PROGMEM int16_t DCC_Addr_List[] =
       {
       DCC_DISABLE_SOUND_ADDR,
       DCC_ENABLE_SOUND_ADDR,
       DCC_VOLUME_DN_ADDR,
       DCC_VOLUME_UP_ADDR,
       DCC_VOLUME_1_ADDR,
       DCC_VOLUME_2_ADDR,
       DCC_PLAY_SOUND1_ADDR,
       DCC_PLAY_SOUND2_ADDR,
       DCC_PLAY_SOUND3_ADDR,
       DCC_PLAY_SOUND4_ADDR,
       DCC_PLAY_SOUND5_ADDR,
       DCC_PLAY_SOUND6_ADDR,
       DCC_PLAY_SOUND7_ADDR,
       DCC_PLAY_SOUND8_ADDR,
       DCC_DISABLE_LIGHT_ADDR,
       DCC_ENABLE_LIGHT_ADDR,
       DCC_SET_SPEED1_ADDR,
       DCC_SET_SPEED2_ADDR,
       DCC_SET_SPEED3_ADDR,
       DCC_SET_SPEED4_ADDR,
       DCC_STEP_POS_DIR_ADDR,
       DCC_STEP_NEG_DIR_ADDR,
       DCC_ROTATE_POS_DIR_ADDR,
       DCC_ROTATE_NEG_DIR_ADDR,
       DCC_STOPP_ADDR,
       DCC_CALIBRATE_ADDR,
       DCC_SET_POL_REL0_ADDR,
       DCC_SET_POL_REL1_ADDR,
       DCC_AUTO_POL_REL_ADDR,
       DCC_REVERSE_TABLE_ADDR,
       DCC_PORT_ADDR_LIST
       };

//------------------------------------------------------------------------------------
void notifyDccAccTurnoutOutput( uint16_t Addr, uint8_t Direction, uint8_t OutputPower)
//------------------------------------------------------------------------------------
// This function is called whenever a normal DCC Turnout Packet is received
//
// ToDo: Bei ersten mal Min und Max Addr bestimmen bamit es dann schneller geht
{
  /*
  Serial.print(F("notifyDccAccTurnoutOutput: "));
  Serial.print(Addr,DEC) ;
  Serial.print(',');
  Serial.print(Direction,DEC) ;
  Serial.print(',');
  Serial.println(OutputPower, HEX) ;
  */

  // Check the size of the POLARISATION_RELAIS_LIST according to https://scaryreasoner.wordpress.com/2009/02/28/checking-sizeof-at-compile-time/
  #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))                  // If the error "size of array is negative" is generated the
  BUILD_BUG_ON( sizeof(DCC_Addr_List) != (ADD_DCC_ADDR_CNT + PORT_CNT) * sizeof(uint16_t) ); // DCC_PORT_ADDR_LIST has the wrong number of entries

  if (OutputPower)
     {
     static uint32_t LastCall = 0;
     static int16_t  LastAddDir = -1;
     int16_t AddDir = Addr * 2 + Direction;
     if (AddDir >= FIRST_USED_DCC_ADDR && AddDir <= LAST_USED_DCC_ADDR
         && (AddDir != LastAddDir || millis() - LastCall >= 500)) // Prevent multible actions because DCC commands are repeated several times
        {
        LastAddDir = AddDir;
        LastCall = millis();
        for (uint8_t i = 0; i < ADD_DCC_ADDR_CNT + PORT_CNT; i++)
          {
          int16_t AddDir_i = pgm_read_word_near(&DCC_Addr_List[i]);
          if (AddDir == AddDir_i)
             {
             switch (i)
               {          // Attention: Adapt also ADD_DCC_ADDR_CNT if other cases are added
               case 0:    Switch_Sound(1);                       break;  // Disable the sound
               case 1:    Switch_Sound(0);                       break;  // Enable the sound
               case 2:    mp3.volumeDn();                        break;
               case 3:    mp3.volumeUp();                        break;
               case 4:    mp3.setVolume(SOUND_VOLUME1);          break;
               case 5:    mp3.setVolume(SOUND_VOLUME2);          break;
               case 6:    Play_Sound(1);                         break;
               case 7:    Play_Sound(2);                         break;
               case 8:    Play_Sound(3);                         break;
               case 9:    Play_Sound(4);                         break;
               case 10:   Play_Sound(5);                         break;
               case 11:   Play_Sound(6);                         break;
               case 12:   Play_Sound(7);                         break;
               case 13:   Play_Sound(8);                         break;
               case 14:   Switch_Light(0);                       break;
               case 15:   Switch_Light(1);                       break;
               case 16:   Set_MovSpeed(MOVE_SPEED1);             break;
               case 17:   Set_MovSpeed(MOVE_SPEED2);             break;
               case 18:   Set_MovSpeed(MOVE_SPEED3);             break;
               case 19:   Set_MovSpeed(MOVE_SPEED4);             break;
               case 20:   Move_to_Port_or_Pos_from_Act_Port(+1); break;
               case 21:   Move_to_Port_or_Pos_from_Act_Port(-1); break;
               case 22:   Rotate_Continuosly_DCC(+1);            break;
               case 23:   Rotate_Continuosly_DCC(-1);            break;
               case 24:   Stop_If_Moving_and_Disable_Poti();     break;
               case 25:   Auto_Calibrate();                      break;
               case 26:   Set_Pol_Relais_by_DCC(0);              break;
               case 27:   Set_Pol_Relais_by_DCC(1);              break;
               case 28:   Set_Pol_Relais_by_DCC(-1);             break;
               case 29:   Reverse_TurnTable();                   break;
               default:   {// Move to port
                          long Port = Calc_Short_Distance_to_Port(i-ADD_DCC_ADDR_CNT);
                          Move_to_Port(Port, 1); // 1 = Rev_if_Equal
                          }
               }
             }
          }
        }
     }

  /*
  if (OutputPower && Addr >= DCC_DEST_PORT_ADDR && Addr < DCC_DEST_PORT_ADDR + PORT_CNT/2)
     {
     #if 1
       long Port = (Addr-DCC_DEST_PORT_ADDR) + Direction * PORT_CNT/2;
     #else
       long Port = (Addr-DCC_DEST_PORT_ADDR) * 2 + Direction;
     #endif
     Port = Calc_Short_Distance_to_Port(Port);
     Move_to_Port_or_Pos(Port);
     }
  */
}

//--------------------
void setupDCCDecoder()
//--------------------
{
  Dcc.pin(0, 2, 1); // Dcc-Signal an Pin2 ( = Int0 );
  Dcc.init( MAN_ID_DIY, 15, FLAGS_DCC_ACCESSORY_DECODER | FLAGS_OUTPUT_ADDRESS_MODE, 0 ); // ToDo: Was bedeuten die Konstanten ?
}

// It's not possible to disable the writing to the EEPROM in the NmraDcc library
// except by defining the following function

//------------------------------------------------
uint8_t notifyCVWrite( uint16_t CV, uint8_t Value)
//------------------------------------------------
{
  //Dprintf("notifyCVWrite %i %i\n", CV, Value);
  return Value;
}



#else // USE_DCC == 0
//--------------------
void setupDCCDecoder()
//--------------------
{
}
#endif // USE_DCC



//----------
void setup()
//----------
{
  MCUSR = 0;
  #if USE_JQ6500_SERIAL
    mp3.begin(9600);
    //mp3.reset();                  // Not needed
    // The volume is set after displaying the title in Display_Act_Port_and_Set_Pol_Relais()
  #else
    Serial.begin(SERIAL_BAUD);
  #endif

  #if USE_OLED
    u8x.begin();
    u8x.setFont(NORMAL_FONT);
    #if USE_u8x8 == 1
      #if ROTATE_DISPLAY_180_DEG
        u8x.setFlipMode(1);
      #endif
      #if OLED_CONTRAST >= 0
        u8x.setContrast(OLED_CONTRAST);
      #endif
    #endif
  #endif

  Step1.attach(STEP_PIN, DIR_PIN); // A4988 mode: pinStep, pinDir
  #if NOT_ENABLE_PIN != -1
    #if ENABLE_ALWAYS_ON
        FastPin<NOT_ENABLE_PIN>::setOutput();
    #else
      Step1.attachEnable(NOT_ENABLE_PIN, 500, false);
    #endif
  #endif
  Step1.setRampLen(STEPPER_RAMP_LENGTH);  // Beschleunigung

  FastPin<STATUS_LED_PIN>::setOutput();
  pinMode(ZERO_SW_PIN,    INPUT_PULLUP);
  pinMode(ENCODER_SW_PIN, INPUT_PULLUP);

  #if WS281X_DATA_PIN >= 0
    FastLED.addLeds<NEOPIXEL, WS281X_DATA_PIN>(leds, NUM_LEDS);  // GRB ordering is assumed
  #endif


  Do_Diagnose();

  Read_EEPROM();

  Test_Menu(); // Debug

  #if POLARISATION_RELAIS_PIN != -1
    FastPin<POLARISATION_RELAIS_PIN>::setOutput();
  #endif

  #if MOVE_STATUS_PIN != -1
    #if MOVE_STATUS_INVERS == 1
      FastPin<MOVE_STATUS_PIN>::hi();
    #endif
    FastPin<MOVE_STATUS_PIN>::setOutput();
  #endif

  #if MOVING_FLASH_PIN != -1
    #if MOVING_FLASH_INVERS
      MOVING_FLASH_CLR;
    #endif
    FastPin<MOVING_FLASH_PIN>::setOutput();
  #endif


  #if LIGHT_PIN != -1
    FastPin<LIGHT_PIN>::setOutput();
  #endif

  Restore_DCC_Switches();

  if (ee.Flags.Is_Stopped == 0 || ALWAYS_CALIBRATE_AT_START)
     Auto_Calibrate();

               // 1234567890123456
  print_DispY(0, "Turntable\n"
                 "Controll " VerStr "\n"
                 "\n"
                 "by Hardi");
  EndTitelDispl = millis() + 5000;

  Display_Act_Port_and_Set_Pol_Relais();
  Disable_SpeedPoti_if_not_0();

  setupDCCDecoder();
}

/*
 - Lichtschranke prellt
 Messen:
 - Laenge der Zero Markierung (Ist das abhaengig von der Poti Einstellung?)
 - Anzahl der Stepps pro Scheibenumderung
   - Genauigkeit (abhaengig von Geschwindigkeit / Richtung / Gweicht)
 - Flanke abhaengig von der Drehrichtung auswerten

                Steps from Zero: 1383
11:34:12.786 -> Steps from Zero: 1292
11:35:37.677 -> Steps from Zero: 1317
11:37:02.557 -> Steps from Zero: 1298
11:38:27.405 -> Steps from Zero: 1428
                Steps from Zero: 210013
11:34:12.275 -> Steps from Zero: 210119
11:35:37.130 -> Steps from Zero: 210229
11:37:02.040 -> Steps from Zero: 210244
11:38:26.827 -> Steps from Zero: 210005
*/

//-----------------------
void TurnBackAndSetZero()
//-----------------------
{          // 1234567890123456
  print_Disp(" Turn back and\n"
             " set zero pos.\n");
  //Dprintf("TurnBackAndSetZero started\n");

  ee.StepsLastDirChange = Step1.readSteps();    // for HasContact() which is called in CheckAndSetZero()
  Step1.rotate(-1);                             // Rotate in reverse direction
  Step1.setSpeedSteps(TURNBACK_SPEED);
  WaitforZeroSwitch(0);                         // Wait until the switch is released
  Step1.doSteps((long)-3*ee.Steps_Has_Contact); // Start moving enough steps for a stable detection. Cast (long) needed because Steps_Has_Contact is an uint16_t
  while(Step1.moving())                         // Wait until the position is reached
     Flash_StatusLED();

  Step1.rotate(1); // Turn in positive direction
  while(CheckAndSetZero() == 0) // Turn until the zero switch is detected
     Flash_StatusLED();

         //   1234567890123456
  print_Disp(" Zero position\n"
             " recalibrated");
  //Dprintf("End\n");
}

//---------------------------------------
void Debug_Print_HasContact(uint8_t Fact)
//---------------------------------------
{
  //Dprintf("HC=%i mov:%li Exp:%li SHC:%li\n", HasContact(Fact), Step1.readSteps() - ee.StepsLastDirChange, (long)Fact * ee.Steps_Has_Contact, ee.Steps_Has_Contact);
}

//-----------------------------
int8_t HasContact(uint8_t Fact)
//-----------------------------
// Function HasContact welche 1 ist, wenn der Stepper mindestens so lang in positiver Richtung bewegt wurde
// wie das Spiel der Zahnräder * Fact ist.
// Sie ist -1 wenn er in negativer Richtung bewegt wurde.
// Dazu wird Steps und Richtung bei jeder Änderung der Drehrichtung gespeichert.
{
  long moved = Step1.readSteps() - ee.StepsLastDirChange;
  if (digitalRead(DIR_PIN) == 1) // positive direction
       { if ( moved > (long)Fact * ee.Steps_Has_Contact) return  1; }
  else { if (-moved > (long)Fact * ee.Steps_Has_Contact) return -1; }
  return 0;
}

//---------------------------
void Debug_Print_HasContact()
//---------------------------
{
static int8_t Old_HasContact = -2;
  int8_t Contact = HasContact(1);
  if (Old_HasContact != Contact)
     {
     Old_HasContact = Contact;
     Dprintln2("HasContact:", Contact);
     }
}


#define PRINT_ZERO 0
//----------------------
int8_t CheckAndSetZero()
//----------------------
// Die Funktion muss sehr schnell periodisch aufgerufen werden. Sie prüft den
// Nullpunktschalter und setzt den Nullpunkt neu wenn sich die Scheibe mehr als
// eine Umdrehung in positiver oder negativer Richtung gedreht hat. Wenn der
// Nullpunkt sonst erkannt wurde, dann wird nur die Abweichung zur letzen Messung
// angezeigt, der Nullpunkt aber nicht korrigiert.
// Der Nullpunkt soll nur dann gesetzt werden wenn siech der Motor einige Zeit
// in positiver Richtung gedreht hat damit das Spiel der Zahnräder keine (so große)
// Rolle Spielt.
{
  static bool OldZero = 1;
  long ActSteps = Step1.readSteps();
  bool Zero = Get_Zero_SW();
  bool Dir  = digitalRead(DIR_PIN);
  int8_t ret = 0;

  if (ActSpeed > 50) // Moving ? (Prevent setting the zero pos if the turntable is moved manualy)
     {
     // Used for HasContact()
     if (Dir != ee.OldDir)
        {
        ee.OldDir = Dir;
        ee.StepsLastDirChange = ActSteps;
        }
     //Debug_Print_HasContact();

     bool RetAndSetZero = false;
     if (OldZero == 0 && Zero == 1) // Transition from 0->1
        {
        if (Dir > 0)
             {
             #if PRINT_ZERO
                 Serial.print(F("Zero dif:")); Serial.print(Steps_to_mm(ActSteps)); Serial.println(F(" mm"));
             #endif
             if ((ALWAYS_SET_ZERO_IN_POS_DIR && HasContact(2) > 0 ) || Abs(ActSteps) > (ee.StepsOneTurn / 2)) // Turn in positive direction and pos > 1/2 circumference
                {
                if (HasContact(2) > 0)
                     {
                     Step1.setZero(); // Problem: Evtl. dauert die Abfrage zu lange oder die Function wurde nicht oft genug aufgerufen weil das Programm beschäftigt war
                     ret = 1;
                     #if PRINT_ZERO
                       Serial.println(F("setZero"));
                     #endif
                     if (Move_to_Port_Act)
                        {
                        ee.Act_Port -= PORT_CNT;
                        // Dprintf("Act_Port corrected:%i\n", ee.Act_Port);
                        }
                     }
                else {
                     RetAndSetZero = 1;
                     //Debug_Print_HasContact(2); // Debug
                     }
                }
             }
        else { // reverse direction
             #if PRINT_ZERO
                 //if (HasContact(2))
                 //   { Serial.print(F("Zero dif rev:")); Serial.print(Steps_to_mm(ActSteps - NegZeroOffs)); Serial.println(F(" mm"));}
             #endif
             if (ActSteps < -(ee.StepsOneTurn / 2)) // Turn in negative direction and pos < - 1/2 circumference
                RetAndSetZero = 1;
             }
        } // Transition form 0->1
     OldZero = Zero;

     if (RetAndSetZero)
        {
        TurnBackAndSetZero();
        ret = -1;
        if (Move_to_Port_Act)
           {
           if (Command < 0)
                Command += PORT_CNT;
           else Command -= PORT_CNT;
           ee.Act_Port = Command;
           ee.Rev_Port = PORT_UNKNOWN;   // Warum das ?
           Step1.setSpeedSteps(MovSpeed);
           long Pos = Calc_Steps_from_PortNr(Command);
           Step1.writeSteps(Pos);
           //Dprintf("New Command:%i Pos:%li\n", Command, Pos);
           }
        }
     } // ActSpeed > 50
  return ret;
}

//--------------------------------------
void WaitUntilStopped(bool DisableA4988)
//--------------------------------------
{
  Set_Moving_Status(1);
  while(Step1.moving())
    {
    Flash_StatusLED();
    CheckAndSetZero();
    }

  if (DisableA4988)
     {
     FastPin<STATUS_LED_PIN>::lo();
     Set_Moving_Status(0);
     }
}

//--------------------------------
long Get_Regular_Pos(uint8_t Port)
//--------------------------------
{
  return Port * ee.StepsOneTurn / PORT_CNT;
}

//----------------------------------------
uint8_t All_Ports_Undefined(uint8_t DirIx)                                                                    // 08.01.21:
//----------------------------------------
{
  for (uint8_t i = 0; i < PORT_CNT; i++)
      {
      if (Read_Port_Pos(DirIx, i) != UNDEF)
         {
         //Dprintln2("All_Ports_Undefined 0", DirIx);
         return 0;
         }
      }
  //DprintlnT("All_Ports_Undefined 1");
  return 1;
}

#if ASK_TO_UPDATE_ALL
//----------------------
void Ask_To_Update_All()
//----------------------
{
  int8_t ActPos = 2; // Start with "Only this"
  uint8_t Res = Proc_Menu(ActPos, 2,
                          // 1234567890123456
                          F("Update ports?\n"  // 1 (Could not be selected)
                            " Only this\n"     // 2     "
                            " All ports\n"     // 3
                            ), 3) -2;          // "-2" to return 0, 1
  if (Res == 1) ee.Flags.Port_Pos_Init = 0;
}
#endif

//---------------
void Sound_Menu()
//---------------
{
  //Dprintln2("Disable_Sound:", Disable_Sound);
  int8_t ActPos = 2 + Disable_Sound;
  uint8_t Res = Proc_Menu(ActPos, 2,
                          // 1234567890123456
                          F("Sound?\n"  // 1 (Could not be selected)
                            " Off\n"    // 2     "
                            " On\n"     // 3
                            ), 3) -2;   // "-2" to return 0, 1
  Switch_Sound(!Res);
  //Dprintln2("Res:", Res);
}


//-------------------------------------------------------------
void Write_Port_Position_to_EEPROM(uint8_t Port, uint8_t DirIx)
//-------------------------------------------------------------
// DirIx=0 if positive direction
//       1 if negative direction
//       2 if rotate postion
{
  if (Port < PORT_CNT)
     {
     long StorePos = Step1.readSteps() % ee.StepsOneTurn;                                                     // 06.01.21:
     if (StorePos < 0) StorePos += ee.StepsOneTurn;
     uint8_t Define_All = (ee.Flags.Port_Pos_Init == 0);
     if (Define_All == 0 && DirIx != 2) Define_All = All_Ports_Undefined(DirIx);
     Write_Port_Pos(DirIx, Port, StorePos);
     if (Define_All) // First time called => Fill all port positions
        {
        //Dprintln2("First time called DirIx ", DirIx);
        ee.Flags.Port_Pos_Init = 1;
        long Reg_Pos = Get_Regular_Pos(Port); // Regular position
        long Offs = Read_Port_Pos(DirIx, Port) - Reg_Pos;
        for (uint8_t i = 0; i < PORT_CNT; i++)
            {
            long Pos = (i * ee.StepsOneTurn / PORT_CNT + Offs) % ee.StepsOneTurn;
            if (Pos < 0) Pos += ee.StepsOneTurn;                                                              // 02.01.21:
            Write_Port_Pos(DirIx, i, Pos);
            }
        Write_EEPROM(); // Write the ee.Flags.Port_Pos_Init
        }
     }
}

// Spielzeug Stepper mit 48 Ports (N-Scheibe):
// Abstand zwischen zwei Ports: 683
// StpHasCont:310

//---------------------------------------------------
long Get_Port_Pos_in_Dir(uint8_t Port, uint8_t DirIx)
//---------------------------------------------------
// DirIx: 0 = Positiv direction
//        1 = Negativ direction
{
  long Pos;
  if (ee.Flags.Port_Pos_Init) // Port positions are already initialized
       {
       Pos = Read_Port_Pos(DirIx, Port);
       if (Pos == UNDEF)
          { // Use the other direction
          Pos = Read_Port_Pos(!DirIx, Port);
          if (DirIx) // Negativ direction
               Pos -= ee.Steps_Has_Contact;
          else Pos += ee.Steps_Has_Contact;
          }
       }
  else {
       Pos = Get_Regular_Pos(Port);
       if (DirIx == 1) Pos -= ee.Steps_Has_Contact; // negativ direction ?
       }
   return Pos;
}
 // Die Anzeige schaltet zu frü von 2 nach 3 um: 13461
 //
 // Zwischen 2 und 3: 13554    Berechnet 13564
 // Port[2]=13222 2000000000 2000000000
 // Port[3]=13905 2000000000 2000000000
 //
 // Act:13613 Dir:0
 // 1 Dif:1073 MinDif:65546 Mean:12540 Kleiner:1
 // 2 Dif:391  MinDif:1073  Mean:13222 Kleiner:1
 // 3 Dif:292  MinDif:391   Mean:13905 Kleiner:1
 // 4 Dif:975  MinDif:292   Mean:14588 Kleiner:0



//------------------------------------------
uint8_t Get_Next_Port_from_Actual_Position()
//------------------------------------------
{
  long ActStep = Step1.readSteps() + ee.Steps_Has_Contact / 2;
  if (ActStep < 0) ActStep += 2*ee.StepsOneTurn; // Positive number because the Port_Pos[] is also positiv
  ActStep %= ee.StepsOneTurn;
  long MinDif = ee.StepsOneTurn*2;
  uint8_t MinPort;
  uint8_t DirIx = HasContact(1) >= 0 ? 0 : 1;                                                                 // 17.01.21:
  //Dprint2("Act:", ActStep); Dprintln2(" Dir:", DirIx);
  for (uint8_t j = 0; j < 2; j++)                                                                             // 09.01.21:
    {
    if (j) ActStep += ee.StepsOneTurn;
    for (uint8_t i = 0; i < PORT_CNT; i++)
      {
      long Dif = ActStep - Get_Port_Pos_in_Dir(i, DirIx);                                                     // 17.01.21:  New
      //long Dif = ActStep - Get_Mean_Stepps_for_Port(i);                                                     // 17.01.21:  Old
      Dif = Abs(Dif);
      //Dprintf("%i Dif:%li MinDif:%li Mean:%li Kleiner:%i\n", i, Dif, MinDif, Get_Mean_Stepps_for_Port(i), Dif < MinDif);
      if (Dif < MinDif)
         {
         MinDif = Dif;
         MinPort = i;
         }
      }
    }
  //Dprintln2("Get_Next_Port_from_Actual_Position:", MinPort);
  return MinPort;
}

//-------------------------------------------------
void Set_Act_Port_from_Actual_Position_if_Unknown()
//-------------------------------------------------
{
  if (ee.Act_Port == PORT_UNKNOWN)
     {
     //DprintlnT("Port Unknown in Set_Act_Port..");
     ee.Act_Port = Calc_Short_Distance_to_Port(Get_Next_Port_from_Actual_Position());
     }
}

#if USE_3_PORT_POS
//-------------------------------------------------
uint8_t Ask_to_Save_Rev_or_Norm_Port(uint8_t DirIx)
//-------------------------------------------------
// Return 0 if reverse is selected
//        1 if normal  is selected
//        2 it its aborted
// DirIx: 0 = Positiv direction
//        1 = Negativ direction
{
  int8_t ActPos = 2; // Start with "No"
  uint8_t Res = Proc_Menu(ActPos, 2,
                          // 1234567890123456
                          F("Save position?\n"  // 1 (Could not be selected)
                            " Reverse side\n"  // 2     "
                            " Normal side\n"   // 3
                            " Abort"           // 4
                            ), 4) -2;          // "-2" to return 0, 1 or 2

  //Dprintln2("Ask_to.. DirIx:", DirIx);
  if (Res == 0 && DirIx == 1)
     {            // 1234567890123456
     print_DispY(0, "Position must\n"
                    "be reached in\n"
                    "positiv dir.\n"
                    "to be saved!");
     delay(3000);
     return 2;
     }
  return Res;
}
#endif

//----------------------------------------------
void Write_Port_Position_to_EEPROM_with_Dialog()
//----------------------------------------------
{
  int8_t HasCont = HasContact(2);
  if (HasCont == 0)
       {            // 1234567890123456
       print_DispY(0, "Err: Turn dir.\n"
                      "changed when\n"
                      "moving to port.");
       delay(3000);
       return ;
       }
  Set_Act_Port_from_Actual_Position_if_Unknown();

  int16_t Port = ee.Act_Port;
  while(1)
      {
      if (Port < 0) Port += 2*PORT_CNT;   // 09.01.21:  Added 2* tp prevent problems if Port < 24
      Port %= PORT_CNT;                                                                                       // 06.01.21:
      if (ee.Flags.Port_Pos_Init == 0) // First time called => the user could select the destination port
         {            // 1234567890123456
         print_DispY(0, "Select port\n"
                        "to be saved #", Intern2DispPort(Port));
         }
      while(Encoder_Button_Pressed()); // Button still pressed from the menu
      Check_Rotary_Encoder(NULL);      // Prevent wrong position when the button is released
      while (1)
        {
        if (ee.Flags.Port_Pos_Init || Encoder_Button_Pressed())
           {
           uint8_t DirIx = HasCont>0 ? 0:1;
           #if USE_3_PORT_POS
           //Dprintln2("Save: ee.Rev_Port:", ee.Rev_Port);
           if (ee.Rev_Port != PORT_UNKNOWN)
                {
                switch (Ask_to_Save_Rev_or_Norm_Port(DirIx))
                   {
                   case 0: // Save the reverse position
                           if (ee.Rev_Port < 0) ee.Rev_Port = -(ee.Rev_Port + 1); // "+1" because the we have to subtract 1 to be able to mark pos 0 as changed
                           Port =  ee.Rev_Port;
                           DirIx = 2;
                           break;
                   case 1: break; // Save normal position
                   case 2: // Abort
                           Display_Act_Port_and_Set_Pol_Relais();
                           return ;
                   }
                }
           #endif

           if (ee.Flags.Port_Pos_Init != 0)
              {
              #if ASK_TO_UPDATE_ALL == 1
                  if (Port == 0) Ask_To_Update_All();
              #endif
              #if ASK_TO_UPDATE_ALL > 1
                  Ask_To_Update_All();
              #endif
              }
           //          1234567890123456
           print_Disp("Position saved\n"
                      "to port %", Intern2DispPort(Port));
           if (DirIx != 2) ee.Act_Port = Port;
           //Dprintln2("Act_Port:", ee.Act_Port);

           Write_Port_Position_to_EEPROM(Port, DirIx);
           while(Encoder_Button_Pressed());
           return;
           }

        int8_t Delta = Check_Rotary_Encoder(NULL);
        if (Delta)
           {
           Port += Delta;
           break; // Leave the while(1) loop
           }
        }
      }
}

//----------------
void Move_Manual()
//----------------
// Move the stepper manually with the rotation switch
{
  // while(Encoder_Button_Pressed()); // Button still pressed from the menu
  // Check_Rotary_Encoder(NULL);      // Prevent wrong position when the button is released
  long OldPos = Step1.readSteps();
  long StepPos = 0;
  uint32_t LastTime = 0;
  uint8_t  Cnt = 0;
  while(1)
      {         //    1234567890123456
      print_DispY(0, "Change position\n"
                     "with the rotary\n"
                     "\n"
                     "key: #",StepPos);
      while (1)
        {
        if (Encoder_Button_Pressed())
           {
           ee.Act_Port = PORT_UNKNOWN;
           return;
           }
        long Delta = Check_Rotary_Encoder(NULL);
        if (Delta)
           {
           if (millis() - LastTime < 200)
                {
                Cnt++;
                if (Cnt > 3)  Delta *= FAST_MOVE_MANUAL_STEP;
                }
           else {
                Cnt = 0;
                Delta *= SLOW_MOVE_MANUAL_STEP;
                }
           //Dprintln2("S:", Delta);
           LastTime = millis();

           StepPos += Delta;
           long Limmit = ee.StepsOneTurn/2;
           if (StepPos >  Limmit) StepPos = Limmit;
           if (StepPos < -Limmit) StepPos = - Limmit;
           Step1.writeSteps(OldPos + StepPos);

           bool Dir = Delta > 0;  // Used for HasContact()
           if (Dir != ee.OldDir)
              {
              ee.OldDir = Dir;
              ee.StepsLastDirChange = StepPos;
              //Dprintln2("Dir:", Dir);
              }

           if (ee.Flags.Is_Stopped)
              {
              ee.Flags.Is_Stopped = 0;
              Write_EEPROM();
              Step1.setSpeedSteps(MOVE_SPEED1);
              }
           break; // Leave the inner while(1) loop
           }
        }
      }
}



//-------------------------------------
long Calc_Steps_from_PortNr(int PortNr)
//-------------------------------------
// PortNr could be greater then PORT_CNT and smaller than 0                      // Not Finished
// In this case ee.StepsOneTurn is added / Substacted
// => The position would be not very acurate since StepsOneTurn is inaccurate
{
  int Port = PortNr;
  long Pos, Add_Stepps = 0;
  //Dprint2("Calc_Steps_from_PortNr(", PortNr); DprintA(") ");

  while (Port < 0)
    {
    Port += PORT_CNT;
    Add_Stepps -= ee.StepsOneTurn;
    }
  while (Port >= PORT_CNT)
    {
    Port -= PORT_CNT;
    Add_Stepps += ee.StepsOneTurn;
    }
  //Dprint2("After while ", Port); DprintA(" ");

  //if (Add_Stepps) Dprintln2("Add_Stepps:", Add_Stepps); // Debug

  if (ee.Flags.Port_Pos_Init) // Port positions are already initialized
       {
       int8_t Stored_Dir;
       // Get a first pos for the DirIx calculation
       if (     Read_Port_Pos(0, Port) == UNDEF) { Stored_Dir = 1; Pos =  Read_Port_Pos(1, Port); }
       else if (Read_Port_Pos(1, Port) == UNDEF) { Stored_Dir = 0; Pos =  Read_Port_Pos(0, Port); }
       else                                      { Stored_Dir = 2; Pos = (Read_Port_Pos(0, Port) + Read_Port_Pos(1, Port)) / 2; } // Average position is used
       Pos += Add_Stepps;
       uint8_t DirIx = Pos >= Step1.readSteps() ? 0 : 1;  // DirIx=0 if positive direction
       if (Stored_Dir == 2) // Both directions are stored
            {
            Pos = Read_Port_Pos(DirIx, Port) + Add_Stepps;
            //Dprint2("Both Dir stored: Using ", DirIx == 0 ? "pos" : "neg"); DprintlnT(" dir");
            }
       else {
            //Dprint2("One Dir stored: Using ", DirIx == 0 ? "pos" : "neg"); DprintlnT(" dir");
            if (Stored_Dir != DirIx) // Stored direction doesn't match with the turn direction
               {
               if (DirIx == 0) // positive direction but we have only the negative direction in the EEPROM
                    Pos += ee.Steps_Has_Contact;
               else Pos -= ee.Steps_Has_Contact;
               //DprintA(" with Steps_Has_Contact");
               }
            //DprintlnT("");
            }
       }
  else { // Port positions are not initialized
       Pos = Get_Regular_Pos(Port) + Add_Stepps;
       if (Pos < Step1.readSteps()) Pos -= ee.Steps_Has_Contact; // negativ direction ?
       }
  //Dprint2("Pos:", Pos);
  return Pos;
}

//----------------------
void Display_Dest_Port()
//----------------------
{
  int16_t Port = ee.Act_Port + 2*PORT_CNT;  // Make sure that it's not negativ
  Port %= PORT_CNT;
           // 1234567890123456
  print_Disp("Move to Port #", Intern2DispPort(Port));
}

/*
Other way to check the polorisation. But this method uses 6 byte more memory if 24 Ports are used
const PROGMEM uint8_t PolarisationBin[((PORT_CNT-1)/8)+1] = { 0b00000000, 0b00001111, 0b11111111 };
  if (pgm_read_byte(&PolarisationBin[Port/8]) & (0b10000000>>Port%8))
*/

//--------------------------------------------
void Set_Polarisation_Relais_OnOff(uint8_t On)
//--------------------------------------------
{
  #if POLARISATION_RELAIS_PIN != -1
    if (On)
    #if POLARISATION_RELAIS_INVERS
         FastPin<POLARISATION_RELAIS_PIN>::lo();
    else FastPin<POLARISATION_RELAIS_PIN>::hi();
    #else
         FastPin<POLARISATION_RELAIS_PIN>::hi();
    else FastPin<POLARISATION_RELAIS_PIN>::lo();
    #endif
  #endif
}


//----------------------------------------
void Set_Polarisation_Relais(uint8_t Port)
//----------------------------------------
{
#if POLARISATION_RELAIS_PIN != -1
  if (Polarisation_Releais_is_set_by_DCC) return ;
  // Check the size of the POLARISATION_RELAIS_LIST according to https://scaryreasoner.wordpress.com/2009/02/28/checking-sizeof-at-compile-time/
  #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)])) // If the error "size of array is negative" is generated the
  BUILD_BUG_ON( sizeof(Polarisation) != PORT_CNT );                         // POLARISATION_RELAIS_LIST has the wrong number of entries

  Set_Polarisation_Relais_OnOff(pgm_read_byte(&Polarisation[Port]));
#endif
}

//-------------------------------------
void Set_Pol_Relais_by_DCC(int8_t Mode)
//-------------------------------------
{
#if POLARISATION_RELAIS_PIN != -1
  if (Mode >= 0)
     {
     Polarisation_Releais_is_set_by_DCC = 1;
     Set_Polarisation_Relais_OnOff(Mode);
     }
  else Polarisation_Releais_is_set_by_DCC = 0;
#endif
}

//----------------------------------------
void Display_Act_Port_and_Set_Pol_Relais()
//----------------------------------------
{
  int16_t Port; // Must be an int16_t ho be able to store 2*PORT_CNT
  if (ee.Act_Port == PORT_UNKNOWN)
       Port = Calc_Short_Distance_to_Port(Get_Next_Port_from_Actual_Position());
  else Port = ee.Act_Port;

  Port += 2*PORT_CNT;
  Port %= PORT_CNT;

  Set_Polarisation_Relais(Port);

  if (millis() >= EndTitelDispl)
     {
     int8_t DispPort = Intern2DispPort(Port);
     if (Rev_Port_Undefined)
          {
          //Dprint2("Port:", Port); Dprintln2(" DispPort:", DispPort);
          if (ee.Act_Port == PORT_UNKNOWN)
               print_Disp("\t~Port #", DispPort);
          else print_Disp("\t Port #", DispPort);
          }
     else { // ee.Rev_Port is defined
          #if USE_LARGE_FONT_FOR_NUMBERS
              print_DispY(8, "\t~Port #\n"
                             "\n"
                             "\t Rev. #", DispPort, Intern2DispPort(abs(ee.Rev_Port)));
          #else
              print_Disp(    "\t~Port #\n"
                             "\t Rev. #", DispPort, Intern2DispPort(abs(ee.Rev_Port)));
          #endif
          }
     EndTitelDispl = 0;

     #if USE_JQ6500_SERIAL
       #if JQ6500_VOLUME != -1
         mp3.setVolume(JQ6500_VOLUME);
       #endif
     #endif
     }
}
/*
 Problem:                                                                                                     09.01.21:
 - Wenn er auf  Port 1 bei Pos -1400 steht und man ein zurück dreht, dann dreht er sich
   zwei mal in die falsche Richtung bis er bei 24 ist
   Reproduzierbar mit:
     -1400
     1
     -
   => Fehler behoben. In Move_to_Port_or_Pos_from_Act_Port(). Port war -25

 - Act_Port stand nach reset auf 1 bei r wurde aber 233 angezeigt
   Aufgetreten nach dem das EEPROM Gelöscht wurde
   - Vorher hat er auch schon beim rückwärts drehen zu 24 in die Falsche richtug gedreht
   => Fehler Behoben. In Write_Port_Position_to_EEPROM_with_Dialog war Port < 24

 - Die Zweite Port[] Spalte wurde nicht geschrieben
   Es wurde auch All_Ports_Undefined 0 anzezeigt
   Evtl. Ist DirIx falsch
   => Fehler Behoben

 17.01.21:
 Die der Erweiterung dass er sich erst zum Kontakt Punkt dreht funktioniert noch nicht so richtig.
 Diese Erweiterung ist Problematisch weil der Drehschalter eingelesen und Angezeigt werden soll
 während sich die Bühne zum Kontaktpunkt dreht.
 Darum wurde die Variable Dest_StepPos eingeführt. Diese wird in der Hauptschleife() geprüft
 und abgearbeitet wenn die Drehung zum Kontaktpunkt beendet ist. Dazu wird Step1.moving()
 geprüft.
 - Manchmal bleibt er einfach stehen und es wird der falsche Port angezeigt
   Das ist auch nach einem Neustart
 - Move Back and Set Zero geht nicht richtig

*/


//--------------------------------
void Move_to_StepPos(long StepPos)
//--------------------------------
{
  ee.Flags.Is_Stopped = 0;
  Write_EEPROM();
  ActSpeed = MovSpeed;
  //Step1.setSpeedSteps((ActSpeed = MovSpeed));
  Command = CMD_MOVE2STEP;    // Moved above Set_Moving_Status() to play sound 1
  Set_Moving_Status(1);
  if (!Move_to_Contact_Point_is_Bussy)
     {
     int8_t Dir = StepPos >= Step1.readSteps() ? 1 : -1;
     Move_to_Contact_Point(Dir, false); // Move fast to the contact point                                     // 17.01.21:
     }
  Dest_StepPos = StepPos;
  //Dprintln2("Dest_StepPos:", Dest_StepPos);
  //Step1.writeSteps(StepPos);                                                                                  // 16.01.21:  Moved down to play the sound before
}


//--------------------------------------------------
void Move_to_Port(int8_t Port, uint8_t Rev_if_Equal)
//--------------------------------------------------
{
  // Pos could be negativ to move in opposite direction
  if (ee.Act_Port != PORT_UNKNOWN && ee.Act_Port < 0)                                                         // 10.01.21:
     ee.Act_Port += PORT_CNT;
  int8_t PosPort = Port;                                                                                      // 10.01.21:
  if (PosPort < 0) PosPort += PORT_CNT;
  if (PosPort == ee.Act_Port && Rev_if_Equal)
     {
     #if REVERSE_IF_SAME_PORT_IS_RECEIVED
         if (Step1.moving() == 0)                                                                             // 12.01.21:
            Reverse_TurnTable();
     #endif
     return;
     }
  ee.Act_Port = Port;
  ee.Rev_Port = PORT_UNKNOWN;
  //Dprintln2("Command: ", Command);
  Display_Dest_Port();
  long StepPos = Calc_Steps_from_PortNr(Port);
  Move_to_StepPos(StepPos);
  Command = Port;
}


/* Old 10.01.21:
//----------------------------------------------
void Move_to_Port_or_Pos(long Pos, uint8_t Mode)
//----------------------------------------------
// Mode could be
//  MPP_AUTO
//  MPP_PORT
//  MPP_SPOS
{
  Dprintln2("Move_to_Port_or_Pos:", Pos);
  if (Mode == MPP_PORT || Mode == MPP_NOREV || (Mode == MPP_AUTO && Abs(Pos) <= 2*PORT_CNT)) // small numbers are port numbers
       {
       if (ee.Act_Port != PORT_UNKNOWN && ee.Act_Port < 0)       // 10.01.21:
          {
          Dprint2("Act_Port ist Neg:", ee.Act_Port);
          ee.Act_Port += PORT_CNT;
          Dprintln2(" => Korrigiert:", ee.Act_Port);
          }
       // Pos could be negativ to move in opposite direction
       int8_t PosPos = Pos;                                   // 10.01.21:
       if (PosPos < 0) PosPos += PORT_CNT;
       if (PosPos == ee.Act_Port && Mode != MPP_NOREV)
          {
          #if REVERSE_IF_SAME_PORT_IS_RECEIVED
              Reverse_TurnTable();
          #endif
          return;
          }
       Command = ee.Act_Port = Pos;
       ee.Rev_Port = PORT_UNKNOWN;
       //Dprintln2("Command: ", Command);
       Display_Dest_Port();
       Pos = Calc_Steps_from_PortNr(Pos);
       }
  else Command = CMD_MOVE2STEP;
  ee.Flags.Is_Stopped = 0;
  Write_EEPROM();
  Step1.setSpeedSteps((ActSpeed = MovSpeed));
  Step1.writeSteps(Pos);
  Set_Moving_Status(1);
}
*/

//-------------------------------------------------------
void Move_to_Port_or_Pos_from_Act_Port(int8_t Delta_Port)
//-------------------------------------------------------
{
  Set_Act_Port_from_Actual_Position_if_Unknown();
  int16_t Port = ee.Act_Port + Delta_Port;
  //Dprint2("Mo Act:", ee.Act_Port); Dprint2(" Port:", Port);
  if (Port<0) Port += 2*PORT_CNT; // Prevent negativ numbers       // 09.01.21:  Added 2* to prevent problems when Port=-25
  Port %= PORT_CNT;               // Range from 0 to PORT_CNT-1

  Port = Calc_Short_Distance_to_Port(Port);
  //Dprintln2("Calc:", Port);
  Move_to_Port(Port, 1); // 1 = Rev_if_Equal
}

//-----------------------------------------
long Get_Mean_Stepps_for_Port(uint8_t Port)
//-----------------------------------------
{
  if (ee.Flags.Port_Pos_Init) // Port positions are already initialized
       {
       if (Read_Port_Pos(0, Port) == UNDEF) return Read_Port_Pos(1, Port);
       if (Read_Port_Pos(1, Port) == UNDEF) return Read_Port_Pos(0, Port);
       return (Read_Port_Pos(0, Port) + Read_Port_Pos(1, Port)) / 2;  // Average position is used
       }
  else {
       return Get_Regular_Pos(Port);
       }
}


//------------------------------------------
int Calc_Short_Distance_to_Port(int8_t Port)
//------------------------------------------
// Calculate the shortest distance to the given port.
// Valid port numbers are in the range from 0 to PORT_CNT - 1
// The result is a number in the range form -2 x PORT_CNT to +2 x PORT_CNT
// which could be handled by Calc_Steps_from_PortNr
{
  long d[5], MinVal = 2000000000, IsPos = Step1.readSteps();
  uint8_t MinPos;
  //Dprint2("IsPos IsPos); Dprintln2(" Port ", Port);
  d[0] = Get_Mean_Stepps_for_Port(Port);
  d[1] = d[0] + ee.StepsOneTurn;
  d[2] = d[1] + ee.StepsOneTurn; //  2x StepsOneTurn   Start with positive moves because they are more acurate
  d[3] = d[0] - ee.StepsOneTurn;
  d[4] = d[3] - ee.StepsOneTurn; // -2x StepsOneTurn
  for (uint8_t i = 0; i < 5; i++)
    {
    long Act = IsPos - d[i];
    if (Act < 0) Act = -Act;
    //Dprintf("d[%i]=%li %li %li\n", i, d[i], Act, MinVal);
    if (Act < MinVal)
       {
       MinVal = Act;
       MinPos = i;
       }
    }
  //Dprintln2("MinPos", MinPos);
  switch(MinPos)
    {
    case 0:  return Port;
    case 1:  return Port+  PORT_CNT;
    case 2:  return Port+2*PORT_CNT;
    case 3:  return Port-  PORT_CNT;
    default: return Port-2*PORT_CNT;
    }
}
/*
 Bei einer 180° Drehung sollte die Position auch gespeichert werden
 damit diese auch exakt angefahren werden kann.
 Wenn ee.Act_Port == PORT_UNKNOWN ist, dann dreht sich die Scheibe einfach um 180°
   Problem dabei ist das Spiel der Zahnräder. Wenn HasContact(1) 0 meldet wissen
   wir nicht genau wo sich die Scheibe befindet. Aber eigentlich liegt der Motor
   immer an einer der beiden Seiten an. Man kann ihn ja per Poti nicht anders steuern.
 Wenn ee.Act_Port bekannt ist, dann kann man aus dem Port_Pos[] Array die Position auslesen
   sofern sie gespeichert wurde. Das speichern ist wichtig wenn die Schiene nicht exakt
   Symetrisch montiert wurde. Dann hat man aber auch ein Problem wenn man rückwärts
   "Einparken" will. Eigentlich braucht man einen Reverse Befehl dem man eine bestimmten
   Anschluss übergeben kann. "r3". Dann steht die Lok rückrärts an dem Anschluss 3

 Beim Rotieren merkt sich das Programm den Ausgangsport in der Varaible ee.Rev_Port.
 Bei einem zweiten Rotate Befehl dreht sich die Scheibe wieder zu diesem Punkt.
 Die Variable wird gelöscht wenn man die Scheibe dreht.
 Zu jedem Port wird auch eine Position gespeichert welche genau passend für eine 180 Grad
 Drehung zu dem Port Ausgangsport passt.
 Im Display wird
   ~Port 19
    Rev. 7
 Angezeigt.
*/

/* Problem:
   Ausgangs Situation: "?": Pos:-344 Port:2
   - "r" => Dreht um 180°
   - Meldungen:
     -> Cmd:r
     -> Reverse_TurnTable Rev_Port=-127
     -> Act_Port:255 Raw Act_Port:-2
   => Behoben
*/

//----------------------
void Reverse_TurnTable()
//----------------------
{
  //Dprintln2("Reverse_TurnTable Rev_Port=", ee.Rev_Port);
  if (!Rev_Port_Undefined) // Has been moved to this position with the "Reverse" command  (Rev_Port is defined (>= 0))
       {
       //Dprintln2("Rev_Port:", Intern2DispPort(ee.Rev_Port));
       ee.Act_Port = ee.Rev_Port;
       Move_to_Port(ee.Rev_Port, 0);  // 0 = No reverse
       ee.Rev_Port = PORT_UNKNOWN;
       }
  else { // Reverse port is not defined
       //Dprint2("Act_Port:", Intern2DispPort(ee.Act_Port)); Dprintln2(" Raw Act_Port:", ee.Act_Port);
       // Problem Act_Port kann auch -3 sein wenn man von hinten kommt => Das darf nicht sein
       uint8_t Move_Started = 0;
       if (ee.Act_Port != PORT_UNKNOWN)
          {
          ee.Rev_Port = ee.Act_Port;
          if (ee.Rev_Port < 0) ee.Rev_Port += PORT_CNT; // 10.01.21:
          #if USE_3_PORT_POS
            long StepPos = Read_Port_Pos(2, ee.Rev_Port); // read the reverse pos
            if (StepPos != UNDEF)
                 {
                 if (Step1.readSteps() > StepPos) StepPos += ee.StepsOneTurn; // Die Scheibe muss sich immer in positiver Richtung drehen
                 //Dprintln2("Move2Rev StepPos:",StepPos);
                 Move_to_StepPos(StepPos);
                 Move_Started = 1;
                 ee.Act_Port = PORT_UNKNOWN;
                 }
          #endif
          }

       if (Move_Started == 0)
          {
          long AddSteps = 0;
          if (HasContact(1) == -1)
             AddSteps = ee.Steps_Has_Contact;
          // Problem if HasContact(1) == 0
          Move_to_StepPos(Step1.readSteps() + AddSteps + ee.StepsOneTurn / 2);
          ee.Act_Port = PORT_UNKNOWN;
          }
       }
  //          1234567890123456
  print_Disp("   Reversing\n"
             "   turntable");
}

//---------------------------
void Software_Reset_in_4sec()
//---------------------------
{
  #if USE_JMP0_RESET
    delay(4000);
    asm volatile ("  jmp 0"); // Restarts program from beginning but does not reset the peripherals and registers
  #else
    wdt_enable(WDTO_4S);      // Doesn't work with (very) old Bootloaders because here the Watchdog isn't disabled
    while(1);                 // (See: https://www.eevblog.com/forum/microcontrollers/atmega328p-watchdog-timer-gives-infinite-reset-loop/)
  #endif
}

//-----------------------------
void Erase_EEPROM_And_Restart()
//-----------------------------
{
  //          1234567890123456
  print_Disp(" Erasing EEPROM\n"
             " and restarting");
  EEPROM.write(0, 0xFF);
  Software_Reset_in_4sec();
}


//-------------------------------
void Set_MovSpeed(uint16_t Speed)
//-------------------------------
{
  MovSpeed = Speed;
  if (Move_Active) Step1.setSpeedSteps(MovSpeed);
}

//-----------------------------------------------
void Move_to_Contact_Point(int8_t Dir, bool Wait)
//-----------------------------------------------
// Move fast to the contact point and stop
{
  int8_t HasCont = HasContact(1);

  if (HasCont && Dir != HasCont)
     {
     #if MIN_STEPS_HAS_CONTACT > 0
     if (ee.Steps_Has_Contact > MIN_STEPS_HAS_CONTACT)
     #endif
        {
        long StepsToDo = (long)Dir * ee.Steps_Has_Contact;
        //Dprint2("Move fast to the contact Dir:", Dir); Dprint2(" Steps:", StepsToDo); Dprintln2(" HasCont:", HasCont);
        Step1.doSteps(StepsToDo);
        Step1.setSpeedSteps(MOVE_SPEED1);
        if (Wait)
             WaitUntilStopped(false);
        else Move_to_Contact_Point_is_Bussy = true;
        //DprintlnT("End Move to contact");
        }
     }
}

//---------------------------------
void Rotate_Continuosly(int8_t Dir)
//---------------------------------
{
  Set_Moving_Status(1);
  FastPin<STATUS_LED_PIN>::hi();
  if (ee.Flags.Is_Stopped)
     {
     ee.Flags.Is_Stopped = 0;
     Write_EEPROM();
              // 1234567890123456
     print_Disp("Moving manually");

     Move_to_Contact_Point(Dir, true); // Move fast to the contact point
     }
  Step1.setSpeedSteps(ActSpeed);
  Step1.rotate(Dir);
}

//-------------------------------------
void Rotate_Continuosly_DCC(int8_t Dir)
//-------------------------------------
{
  Command = CMD_MOVE_CONT;
  if (ActSpeed == 0) ActSpeed = MOVE_SPEED1;
  Rotate_Continuosly(Dir);
  Disable_SpeedPoti_if_not_0();
}


// Commands:
// m-1000  Move 1000 micro steps counter clock wise
// m+1000  Move 1000 micro steps clock wise
// p+123   Move to step position +123
// s5000   Set the speed to 5000
// ?       Print position
// w+2     Write port position 2 for the positive turning direction (w-2 write the neg. direction)
// ce      Clear EEProm and restart
// +       Next Port
// -       Prior Port
// r       Reverse turn Table
// o       Sound On/Off
// Todo:
// ?e      Print EEPROM

//----------------------------
void Proc_Cmd(const char *Cmd)
//----------------------------
{
  switch(*Cmd)
    {
    case 'm': {
              long move = atol(Cmd+1);
              if (move != 0)
                 {
                 Step1.setSpeedSteps(MovSpeed);
                 Step1.doSteps(move);
                 WaitUntilStopped(true);
                 }
              } break;
    case '?': Serial.print(F("Pos:"));        Serial.print(Step1.readSteps());
              Serial.print(F(" Port:"));      Serial.print(Intern2DispPort(Get_Next_Port_from_Actual_Position()));
              Serial.print(F(" OneTurn:"));   Serial.print(ee.StepsOneTurn);
              Serial.print(F(" Poti:"));      Serial.print(Get_SpeedPoti_raw());
              Serial.print(F(" StpHasCont:"));Serial.println(ee.Steps_Has_Contact);
              //Serial.print(F(" Is_Stopped:"));Serial.println(ee.Flags.Is_Stopped);
              break;
    case 's': Set_MovSpeed(atoi(Cmd+1));
              //Serial.print(F("MovSpeed:")); Serial.println(MovSpeed);
              break;
    case 'w': { // Write Port position to the EEPROM
              int Port = Disp2InternPort(atoi(Cmd+1));
              Write_Port_Position_to_EEPROM(Abs(Port), Cmd[1] == '-' ? 1 : 0);
              } break;
    case 'c': if (Cmd[1] == 'e') // 'ce'
                 Erase_EEPROM_And_Restart();
              break;
    case 'r': Reverse_TurnTable();
              break;
    case 'p': { // Move to step Position
              long StepPos = atol(Cmd+1);
              Move_to_StepPos(StepPos);
              break;
              }
    case 'o': Switch_Sound(!ee.Flags.Disable_Sound);
              Dprintln2("Sound=", !ee.Flags.Disable_Sound);
              break;
    default:  if      (*Cmd == '+' && Cmd[1] == '\0')  { Move_to_Port_or_Pos_from_Act_Port(+1); } // Only "+"
              else if (*Cmd == '-' && Cmd[1] == '\0')  { Move_to_Port_or_Pos_from_Act_Port(-1); } // Only "-"
              else if ((*Cmd >= '0' && *Cmd <= '9') || *Cmd == '+' || *Cmd == '-')
                      {
                      long Port = atoi(Cmd);
                      if (Port >= 1 && Port <= PORT_CNT)
                         {
                         Port--; // The internal numbers start with 0
                         Port = Calc_Short_Distance_to_Port(Port);
                         Move_to_Port(Port, 1);  // 1 = Rev_if_Equal
                         }
                      else Serial.println(F("Wrong Port Nr"));
                      }
              else Serial.println(F("Unknown cmd"));
    }

}

//--------------------------
void Receive_CMD_per_RS232()
//--------------------------
{
  static char Buffer[20] = "";
  if (Serial.available() > 0)
     {
     char c = Serial.read();
     switch (c)
        {
        case '\n': // Proc buffer       (For tests with the serial console of Arduino use "Neue Zeile" and not "..(CR)" )
                   Dprintln2("Cmd:", Buffer);
                   Proc_Cmd(Buffer);
                   Buffer[0] = '\0';
                   break;
        default:   { // Add character to Buffer
                   uint8_t len = strlen(Buffer);
                   if (len < sizeof(Buffer)-1)
                        {
                        Buffer[len++] = c;
                        Buffer[len]   = '\0';
                        }
                   else {
                        *Buffer = '\0';
                        //Serial.println(F("Buffer overflow")); // Debug
                        }
                   }
        }
     }
}

//---------------------
int Get_SpeedPoti_raw()
//---------------------
{
  #if USE_AVDWEB_ANALOGREADFAST
    uint16_t Value = analogReadFast(POTI_PIN);
  #else
    uint16_t Value = analogRead(POTI_PIN);
  #endif

  #define ANALOG_FILTER 4
  #if ANALOG_FILTER
    static uint32_t Buffer = 0xFFFFFFFF;
    if (Buffer == 0xFFFFFFFF)
       Buffer = Value * ANALOG_FILTER;
    Buffer -= Buffer/ANALOG_FILTER;
    Buffer += Value;
    Value   = Buffer/ANALOG_FILTER;
  #endif

  // Serial.println(Value); // debug
  #if SPEED_POTI_DIRECTION  == -1
    return -(-SPEED_POTI_CENTER + Value);
  #else
    return   -SPEED_POTI_CENTER + Value;
  #endif
}

//---------------------------------
void Debug_Print_Check_Speed_Poti()
//---------------------------------
{
/*
  #define Filter 4
  long Avg = Get_SpeedPoti_raw() * Filter;
  uint32_t Last = millis();
  while(1)
    {
    uint32_t t = millis();
    if (t - Last > 100)
       {
       Last = t;
       Avg -= Avg/Filter;
       Avg += Get_SpeedPoti_raw();
       Serial.println(Avg/Filter);
       }
    }
*/
}

//-------------
void Diagnose()
//-------------
// Uses 162 Bytes FLASH
{
#if USE_DIAGNOSE_DISP
  uint32_t LastChk = 0;
  int8_t   RotVal  = 0;
  int8_t   OldRot  = 0;
  int16_t  Poti;
  uint8_t  Cnt = 254;

  while(Encoder_Button_Pressed() == 0)
    {
    RotVal += Check_Rotary_Encoder(NULL);
    if (OldRot != RotVal) Cnt = 254;
    OldRot = RotVal;
    uint32_t t = millis();
    if (t - LastChk >= 100) // Check the poti every 100 ms to update filter
       {
       LastChk = t;
       Poti = Get_SpeedPoti_raw();
       Cnt++;
       if (Cnt >= 10)
          {
          print_Disp("Poti  %\n"
                     "RotSw %",
                     Poti, RotVal);
          Cnt = 0;
          }
       }
    }
#endif
}

//-----------------
int Get_SpeedPoti()
//-----------------
{
  int ad = Get_SpeedPoti_raw();
  if (SpeedPotiDisabled)
     {
     if (Abs(ad) <= SPEED_POTI_MID_RANGE) SpeedPotiDisabled = 0;
     Flash_StatusLED();
     delay(50);
     return 0;
     }
  return ad;
}

//-------------------------------
void Disable_SpeedPoti_if_not_0()
//-------------------------------
{
  int ad = Get_SpeedPoti();
  int Abs_ad = Abs(ad);
  SpeedPotiDisabled = Abs_ad > SPEED_POTI_MID_RANGE;
}

//---------------------
void Proc_Analog_Move()
//---------------------
{
  uint32_t t = millis();
  if (t >= ReadADTimer)
     {
     ReadADTimer = t + 100;
     int ad = Get_SpeedPoti();
     int Abs_ad = Abs(ad);
     if (Abs_ad <= SPEED_POTI_MID_RANGE)
          {
          if (ActSpeed != 0 && ActSpeed < 200) // Problem: The ramp is also used at slow speeds => It takes long to stop   08.01.21:
             {
             //DprintlnT("Fast Stop");
             Step1.setSpeedSteps(20); // Fast stop in max 0.5 sec (Speed is given in stepps in 10s => 2 stepps/s = 0.5s between two steps
             }                        // Not sure if this is generate loosing steps (Should not because it's only called at slow speeds)
          Step1.rotate(0); // Stop
          ActSpeed = 0;
          FastPin<STATUS_LED_PIN>::lo();
          if (!ee.Flags.Is_Stopped  && !Step1.moving())
             {
             ee.Flags.Is_Stopped = 1;
             Write_EEPROM();
             Set_Moving_Status(0);
             //DprintT("Stopped");
             Display_Act_Port_and_Set_Pol_Relais();
             }
          if (EndTitelDispl > 0 && t >= EndTitelDispl)
             Display_Act_Port_and_Set_Pol_Relais();
          }
     else { // Move the turntable
          ee.Act_Port = PORT_UNKNOWN;
          if (ee.Rev_Port >= 0) ee.Rev_Port = -ee.Rev_Port - 1; // "-1" because "0" is a valid port which can't be negated
          Command = CMD_NONE;

          int8_t Dir = ad > 0 ? 1 : -1;
          // Using a quadratic function to define the speed for a finer positioning
          long x2 = Abs_ad - SPEED_POTI_MID_RANGE;
          x2 *=x2;
          ActSpeed = x2 / ANALOG_SPEED_DIVISOR + MIN_ANALOG_SPEED;
          Rotate_Continuosly(Dir);
          //Dprintf("%8li %6u %6li\n", Step1.readSteps(), ActSpeed, x2); // Debug
          //{ static int8_t Last = -1; int8_t p = Get_Next_Port_from_Actual_Position(); if (p != Last) { Last = p; Serial.print(F(" Port:")); Serial.println(Intern2DispPort(p));}}
          }
     }
}

//-------------------
void Stop_If_Moving()
//-------------------
{
  if (Step1.moving()) ee.Act_Port = ee.Rev_Port = PORT_UNKNOWN;
  Step1.rotate(0);
  Command  = CMD_NONE;
}

//------------------------------------
void Stop_If_Moving_and_Disable_Poti()
//------------------------------------
{
  Stop_If_Moving();
  Disable_SpeedPoti_if_not_0();
}

//---------
void loop()
//---------
{
  Receive_CMD_per_RS232();
  #if USE_DCC
    Dcc.process();
  #endif
  // Read the rotary encoder
  Check_Rotary_Encoder(Move_to_Port_or_Pos_from_Act_Port);

  if (Encoder_Button_Pressed())
     {
     uint8_t Show_Normal_Disp = 0;
     EndTitelDispl = 0;
     Stop_If_Moving();
     static int8_t ActPos = 2;
     switch(Proc_Menu(ActPos, 1,
                   //    1234567890123456
                      F("Abort"                  // 1
                        "\n" "Reverse"           // 2
                        "\n" "Sound"             // 3
                        "\n" "Move manual"       // 4
                        "\n" "Save position"     // 5
                        "\n" "Recalibrate"       // 6
                        "\n" "Reset all"         // 7
                        #if USE_DIAGNOSE_DISP
                        "\n" "Diagnose"          // 8
                        #endif
//                      "\n" "Analog mode"       // 9
                        ), 7+USE_DIAGNOSE_DISP)) // Number of menue items
          {
          case 1:                                              Show_Normal_Disp = 1; break; // nothing
          case 2: Reverse_TurnTable();                                               break;
          case 3: Sound_Menu();                                Show_Normal_Disp = 1; break;
          case 4: Move_Manual();                               Show_Normal_Disp = 1; break;
          case 5: Write_Port_Position_to_EEPROM_with_Dialog();                       break;
          case 6: Auto_Calibrate();                                                  break;
          case 7: Erase_EEPROM_And_Restart();                                        break;
          #if USE_DIAGNOSE_DISP
          case 8: Diagnose();                                  Show_Normal_Disp = 1; break;
          #endif
          }
     if (Show_Normal_Disp) Display_Act_Port_and_Set_Pol_Relais();
     while(Encoder_Button_Pressed()); // Wait until the button is released
     }

  if (Dest_StepPos != UNDEF && (Delayed_Start_Moving == 0 || millis() >= Delayed_Start_Moving) && (Move_to_Contact_Point_is_Bussy == false || Step1.moving() == 0))              // 17.01.21:
     { // Delayed start moving after Move_to_Contact_Point() is finished
     //Dprintln2("Dest_StepPos=>UNDEF, Bussy:", Move_to_Contact_Point_is_Bussy);
     Move_to_Contact_Point_is_Bussy = false;
     Step1.setSpeedSteps(ActSpeed);
     Step1.writeSteps(Dest_StepPos);
     Dest_StepPos = UNDEF;
     Delayed_Start_Moving = 0;
     }

  if (Move_Active) // is Move to port or continious move active ?   Move_Active = (Command != CMD_NONE)
       {
       if (Step1.moving())
            {
            Flash_StatusLED();
            }
       else {
            if (Command != CMD_MOVE_CONT && Dest_StepPos == UNDEF)
               {
               FastPin<STATUS_LED_PIN>::lo();
               Set_Moving_Status(0);
               Command = CMD_NONE;
               Disable_SpeedPoti_if_not_0();
               //DprintlnT("STOPPED!!");
               }
            }
       }
  else { // Manual moving the turntable with the poti
       Proc_Analog_Move();
       }

  CheckAndSetZero();

  Update_Moving_Status();

  #if WS281X_DATA_PIN >= 0
    leds[0] = CRGB::Red;
    FastLED.show();
  #endif
}
